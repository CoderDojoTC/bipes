{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BIPES Block Programming with MicroPython","text":"<p>BIPES Block Programming with MicroPython</p> <p>Block-based Integrated Platform for Embedded Systems (BIPES), an open source project developed in partnership with a range of universities to develop a drag-and-drop visual programming environment for the embedded world, has support for the Raspberry Pi Pico and its RP2040 microcontroller.   BIPES has been extended to add support for the RP2040 family of processors, the Raspberry Pi Pico W, and the Maker Pi RP2040 based Optum Bot.  BIPES can be run online as well as locally.</p> <p>Read more about the history of BIPES here</p>"},{"location":"contacts/","title":"BIPES Contacts","text":"<ul> <li>Jim Tannenbaum (aka \"JET\")</li> <li>Dan McCreary</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome anyone that has sample lesson plans they would like to contribute.  You can use the following ways to contribute:</p> <ol> <li>Submit a pull request</li> <li>Add an issue to our issue tracker</li> <li>Send one of us your sample lesson plans or code via e-mail.  You can see our contacts on the Contacts page.</li> </ol>"},{"location":"contributing/#authoring-guidelines","title":"Authoring Guidelines","text":"<p>This site is built using Markdown, GitHub Pages and mkdocs using the mkdocs-material theme.</p> <p>See our authoring guidelines for further details:</p> <p>Content Authoring Guide</p>"},{"location":"glossary/","title":"BIPES Glossary","text":"<p>Here is a glossary of terms we use in these courses.</p>"},{"location":"glossary/#bipes","title":"BIPES","text":"<p>Block-based Integrated Platform for Embedded Systems</p> <p>BIPES was originally developed by Rafael Aroca.  He has been etremely generous in allowing me to \"play in his backyard.\"  Any errors in this implementation of BIPES are my fault -- Jet</p>"},{"location":"glossary/#raspberry-pi-pico","title":"Raspberry Pi Pico","text":"<p>A low-cost $4 microcontroller that you can program with BIPES.</p>"},{"location":"glossary/#maker-pi-rp2040","title":"Maker Pi RP2040","text":"<p>A low-cost $10 development board based on the Raspberry Pi microcontroller chip that you can program with BIPES.</p>"},{"location":"intro/01-intro/","title":"An introduction to BIPES","text":""},{"location":"intro/01-intro/#what-is-bipes","title":"What is BIPES","text":"<p>BIPES (Block based Integrated Platform for Embedded Systems) allows text and block based programming for several types of embedded systems and Internet of Things modules using MicroPython. You can connect, program, debug and monitor several types of boards using a serial USB connection.  </p>"},{"location":"intro/01-intro/#why-bipes-is-fun","title":"Why BIPES is Fun","text":"<p>BIPES hides the complexity of MicroPython by allowing users to program microcontrollers via an easy to use graphical interface similar to Scratch, making it ideal for younger students wanting to experiment with software/hardware interactions.  BIPES has several built in libraries that make adding accessories to your microcontroller simple.  The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts.</p>"},{"location":"intro/01-intro/#about-this-site","title":"About this site","text":"<p>This site provides a rich collection of resources to teach computational thinking to students of all ages using fun programs that control the physical world around us.</p> <p>The sub-field of computer science that reads sensors and controls lights and motors is called Physical Computing. You can read about physical computing on our MicroPython site.</p>"},{"location":"intro/01-intro/#want-to-learn-more","title":"Want to learn more?","text":"<p>This site will concentrate on using BIPES to program the Raspberry Pi Pico and the Cytron Maker Pi 2040 boards.  The lessons are based, in part, on the MicroPython lessons covered in our MicroPython for Kids site.  A discussion of how a breadboard works, different types of microcontrollers, and the Raspberry Pi Pico are all covered on that site.</p>"},{"location":"intro/02-getting-started/","title":"Getting Started","text":"<p>Before getting started with BIPES, follow the directions below to setup your microcontroller.</p>"},{"location":"intro/02-getting-started/#setup","title":"Setup","text":"<p>However, before getting started with BIPES, your microcontroller board must be setup.  Regardless of which board you are using, you should start by doing the following steps:</p> <ol> <li> <p>Get the latest firmware release from MicroPython.org</p> <ul> <li>Download the latest stable uf2 file to your computer</li> </ul> </li> <li> <p>Hold down the boot button on the board (white button)</p> <ul> <li> <p>Plug one end of the USB cable into the board and the other end into your computer</p> </li> <li> <p>Release the boot button</p> </li> </ul> </li> <li> <p>The Pico will show up as a new drive (labeled RPI-RP2) available on your computer</p> </li> <li> <p>Copy the downloaded uf2 file onto the RPI-RP2 drive</p> <ul> <li> <p>The Pico will reboot and be ready to use</p> </li> <li> <p>The RPI-RP2 drive will no longer be visable on your computer.</p> </li> </ul> </li> </ol> <p></p> <p>Modified image courtesy of Raspberry Pi</p>"},{"location":"intro/03-working-with-bipes/","title":"Working with BIPES","text":"<p>Working with BIPES is easy, since there is nothing to load on your computer. BIPES can be found online.  Once the Welcome screen loads in your browser, you can do the following:</p> <ul> <li> <p>Close the Welcome screen</p> </li> <li> <p>There are two configurations you must change.  Your serial port and device.</p> </li> </ul> <p></p> <ul> <li> <p>Connect to your device</p> <ul> <li> <p>Serial connection </p> <ul> <li>On the Mac, the Pico will connect to a port in the <code>/dev/</code> directory such as: <code>/dev/cu.usbmodem140101</code></li> </ul> <p></p> <ul> <li>On the PC, the Pico will connect to a comm port</li> </ul> <p></p> </li> <li> <p>Select the comm port for your board</p> </li> </ul> </li> <li> <p>Select your device:</p> <ul> <li> <p>The Raspberry Pi Pico </p> </li> <li> <p>The Raspberry Pi Pico W </p> </li> <li> <p>The Maker Pi RP2040 </p> </li> <li> <p>The Maker Nano RP2040 </p> </li> </ul> </li> <li> <p>The left navigation pane contains all of the blocks you will need to run the examples for the Raspberry Pi Pico and the Maker Pi RP2040 microcontrollers.</p> </li> </ul> <p></p>"},{"location":"intro/03-working-with-bipes/#using-the-bipes-drag-and-drop-interface","title":"Using the BIPES Drag and Drop Interface","text":""},{"location":"intro/03-working-with-bipes/#adding-a-loop","title":"Adding a loop","text":""},{"location":"intro/03-working-with-bipes/#test-your-connection","title":"Test Your Connection","text":"<p>The best way to test your connection is to write a small program that will flash the on-board LED.  See the basic blink example under Raspberry Pi Pico.</p> <ul> <li>Congratulations!  You are ready to start using BIPES.</li> </ul>"},{"location":"makerpi/01-intro/","title":"Introduction to using a Maker Pi RP2040 board with BIPES","text":"<p>These lessons assume that you have at least skimmed the Getting Started sections and have selected the Maker Pi RP2040 in BIPES to write your code.  It also assumed that you have worked through the examples for the Raspberry Pi Pico.</p> <p>The lessons will introduce you to using BIPES with the Maker Pi RP2040 board and the OptumBot.</p> <p>The first example uses the Maker Pi RP2040 and its internal LED in a similar manner to the exercise that was done with the Raspberry Pi Pico. The subsequent examples will repeat many of the previous examples, then add the unique capabilities of the Maker Pi RP2040.</p>"},{"location":"makerpi/basics/blink/","title":"Blink in BIPES","text":""},{"location":"makerpi/basics/blink/#overview","title":"Overview","text":"<p>In this lab, we will use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second.  The only things you need to run this program are</p> <ol> <li>BIPES</li> <li>a USB cable</li> <li>a Maker Pi RP2040 microcontroller</li> </ol>"},{"location":"makerpi/basics/blink/#blinking-the-builtin-leds","title":"Blinking the Builtin LEDs","text":"<p>The Maker Pi has thirteen built in blue LEDs wired to logical pins.  Here is a sample program that you can use.  It will blink each one of the LEDs in succession, up and down the board.</p> <p></p> <p>Let's take a look at the blocks...  The top left block creates the initial list, in sequence, running from GP0 to GP28 (one general purpose pin for each of the 13 LEDs).  The block immediately below that creates a second list, in reverse order.  On the right side, we set up a variable to control the amount of time between turning an LED on and turning it off.  Then there is a loop that will run forever, or until we stop the program.  Finally, inside the outer loop is two innner loops.  The first walks through each LED, turning it on, waiting 1/4 second, then turning it off.  The second loop does the same, moving the LEDs on and off in the reverse order.  Notice that we have to convert the pin numbers in the second list to integers, since the list was initialized with a string.</p>"},{"location":"makerpi/basics/blink/#changing-the-blink-speed","title":"Changing the Blink Speed","text":"<p>This program will blink the built-in LED on and off every 1/4 of a second.  By changing the delay variable you can make the LEDs blink faster and slower.</p> <p>Challenge</p> <p>What is the fastest you can make the LEDs blink and still see them changing?  What does this tell you about the human eye?</p>"},{"location":"makerpi/basics/buttons/","title":"Buttons, Interrupts, and Functions in BIPES","text":""},{"location":"makerpi/basics/buttons/#overview","title":"Overview","text":"<p>In this lab, we will continue to use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second.  The only things you need to run this program are</p> <ol> <li>BIPES</li> <li>a USB cable</li> <li>a Maker Pi RP2040 microcontroller</li> </ol>"},{"location":"makerpi/basics/buttons/#creating-a-function-to-blink-an-led","title":"Creating a function to blink an LED","text":"<p>We want ot take advantage of BIPES ability to allow us to define our own functions.  So we will use that to create a function to turn an LED on, wait a predetermined amount of time (delay), then turn the LED off, and again wait that same time before return to the calling program.</p> <p></p>"},{"location":"makerpi/basics/buttons/#creating-sequence-variables-to-control-direction","title":"Creating sequence variables to control direction","text":"<p>Next, let's create a pair of variables to determine which direction the LEDs will sequence, forwards or backwards.  Initially, we don't want to have the LEDs blink at all, so we'll set the variables to false.</p> <p></p>"},{"location":"makerpi/basics/buttons/#adding-interrupts-to-capture-button-presses","title":"Adding interrupts to capture button presses","text":"<p>Then, we can set up a pair of interrupts to capture when a button is pressed on the Maker Pi board, indicating the direction to sequence the LEDs.</p> <p></p>"},{"location":"makerpi/basics/buttons/#the-main-loop","title":"The main loop","text":"<p>And finally, the main loop.  It is similar to the previous example; however, there are two added if blocks to determine the sequence direction.</p> <p></p>"},{"location":"makerpi/basics/buttons/#the-entire-set-of-blocks","title":"The entire set of blocks","text":"<p>Putting it all together allows us to sequence the LEDs in one direction, once one button is pressed, then sequence in the opposition direction when the other button is pressed.</p> <p></p> <p>Challenge</p> <p>Can you make the sequence change direction in the middle of a run, rather than waiting for the sequence to complete?</p>"},{"location":"makerpi/optumbot/build/","title":"Building the OptumBot remote control car with the Maker Pi RP2040","text":"<p>The bot brain is the Maker Pi RP2040.  The Maker Pi board makes building a bot simple, since it is a one board solution built around the RP2040.  The board comes with a dual channel DC motor driver, four servo motor ports, seven grove ports, a piezo, and two multi color leds. </p> <p>Maker Pi RP2040 Information</p> <p>The parts kit includes:</p> <p></p> Description Part Chassis kit Maker Pi RP2040 HC-05 or AT-09 Bluetooth module Ultrasonic sensor and mount <p>Additional parts (not included in the kit):</p> <ul> <li>Nuts, bolts, and spacers</li> <li>Wire ties to secure wires</li> <li>Four AA batteries</li> <li>USB Micro B Cable</li> <li>Two optional IR Sensors for line following </li> </ul> <p>Additional software required:</p> <ul> <li>Software capable of connecting to and writing to the bluetooth module (I'm using LightBlue)</li> </ul> <p>Assemble the chassis</p> <p></p> <p>Place the Maker PI RP2040 board on the rear of the chassis as shown and mark the small holes that are in each corner.  Make sure the back of the board is closer to the back of the chassis, since the motors will end up close to the front board mounts.</p> <p></p> <p>Once the holes are marked, drill the holes, using an 1/8 inch drill bit.  Be careful, as your mounting holes may be close to existing mount holes in the chassis.  Also note that the chassis is thin plastic, so it must be supported as you drill through it.</p> <p></p> <p>After the holes are drilled, remove the paper from the chassis, motor mounts, and sensor mount.  All parts should be clear plastic after the paper is romoved.</p> <p></p> <p>Gather the wheel, motor, mounts, long screws, and nut as shown above.  Slide the motor mounts through the chassis, then insert and secure the motor with the screws.  Note that the wires will seperate from the motor if not handled with care.  The wires should be on the side of the motor that faces out from the chassis.  Once the motor is mounted, feed the wires through the chassis and optionally secure them with a wire tie.</p> <p></p> <p>Add the wheel once the motor is mounted and repeat for the other side.</p> <p></p> <p>The battery holder is mounted on the bottom of the chassis, nestled between the motors.  The wires from the battery holder should feed to the rear of the chassis.</p> <p></p> <p>Assemble the rear wheel by adding the standoffs to the castor wheel as shown in the above left image.  Then attach it to the chassis.  The wires for the battery holder are shown feeding through the hole to the left of the motor wires.  They will need to be fed through the right side (assembler error).</p> <p></p> <p>Feed the screws up through the bottom of the chassis in the holes that were drilled.  Use the plastic spacers to separate the board from the chassis (and clear the wires), then secure the board with the nuts.  The board should be mounted such that the connections to the motor and battery wires face the rear of the chassis.  The wires can now be trimmed and attached to the board.  Carefully note that the black battery wire connects to the negative (-) green terminal and the red battery wire attaches to the positive (+) green terminal.  The motor wires should connect to the black terminals, with the black wires on the outside (terminals labeled GP8 and GP 11) and the red wires on the inside (terminals labeled GP 9 and GP 10).</p> <p>Connecting the ultrasonic sensor</p> <p></p> <p>Insert the ultrasonic sensor in the mount with the pins up (it will appear as if the sensor is mounted upside down, well it is).  Then attach the mount to the front of the chassis with the short screws.  The ultrasonic sensor measures distance using sonar, an ultrasonic (well above human hearing) pulse (~40KHz) is transmitted from the unit and distance-to-target is determined by measuring the time required for the echo return.  The pins are labeled on the front of the module - Vcc  (3.3 VDC), Trig, Echo, and Gnd.</p> <p>Connect the grove connector wires as follows:</p> Wire Color Sensor Pin Red Vcc White Trig Yellow Echo Black Gnd <p>Connect the other end of the grove wire harness to the grove 5 port.  Use small wire ties to keep the wires secure.</p> <p>Connecting the bluetooth module</p> <p></p> <p>The bluetooth module will nestle between the wire ties used to tidy up the wires.  The bluetooth modules communicate at 9600 baud by default, although some older modules use 115200 baud.  Communication is done through the built in UART on the board.  The settings (baud rate, name, etc.) can be changed by sending AT commands to the module.  Sending \"AT+HELP\" to the module will return a list of supported commands.</p> <p>The AT commands for getting/setting baud rate are:</p> Send Receive Parameter AT+BAUD? OK+Get:[P1] P1: Baud Rate AT+BAUD[P1] OK+Set:[P1] 0: 9600; 1: 19200; 2: 38400 . 3: 57600; 4: 115200; 5: 4800 . 6: 2400; 7: 1200; 8: 230400 . Default: 0 (9600) <p>The pins are usually labelled on the back of the module.  Your module with either have six or four pins.  Ignoring the outer most pins (assuming your module has six pins), the pins from left to right as you look at the back of the board are VCC (3.3 VDC), Gnd, Tx, &amp; Rx.  Connect the grove connector wires as follows:</p> Wire Color Module Pin Red VCC Black GND Yellow TXD White RXD <p>Connect the other end of the grove wire harness to the grove 3 port.</p> <p>N.B.: If you are using an Apple device to communicate with the bluetooth module, you must use the AT-09 module.  Apple does not support the HC-05 bluetooth version.</p> <p>The instructions for using the line sensors are as follows</p> <p></p> <p>Attach the sensors to the front of the chassis as shown above and the wires as below</p> Wire Color Sensor Pin Red VCC Black GND White DO <p>The left sensor should be connected to Grove 7 and the right sensor should be connected to Grove 1</p>"},{"location":"makerpi/optumbot/follow/","title":"Add an ultrasonic sensor and follow your hand","text":""},{"location":"makerpi/optumbot/follow/#add-an-ultrasonic-sensor-to-your-chassis","title":"Add an ultrasonic sensor to your chassis","text":"<p>Once you added the sensor, build the blocks to initialize the sensor and display the distance reading in the console.  As you run the program, move your hand in front of the chassis such that the distance changes.  Note that your sensor may be connected to a different Grove connector.</p> <p></p>"},{"location":"makerpi/optumbot/follow/#now-add-the-motor-control","title":"Now add the motor control","text":"<p>Once you add the motor control, where do you think the sweet spot is such that it follows your hand as you move your hand away from and towards the sensor?  We picked 100, but you may decide to move the threshold.</p> <p></p>"},{"location":"makerpi/optumbot/motors/","title":"Working with Motors in BIPES","text":""},{"location":"makerpi/optumbot/motors/#assemble-the-two-wheel-smart-car-chassis","title":"Assemble the Two Wheel Smart Car Chassis","text":"<p>Before we work with motors, we'll want to assemble the smart car chassis.  It is available from a number of vendors online.</p> <ul> <li>Cytron 2WD Smart Car Chassis</li> <li>YouTube Video of Assembly - note that he does not remove the backing paper on the Plexiglass and he mounts the battery on the top.  We like ours on the bottom so we can mount the Maker Pi board on top.</li> </ul>"},{"location":"makerpi/optumbot/motors/#check-your-motor-wiring","title":"Check your motor wiring!","text":"<p>Depending on how your motors are wired, you may need to change the motor initialization block from the displayed block below:</p> <p></p> <p>The wiring can be tested by trying the motor movement blocks (forward, left, and right)</p> <p></p> <p>If the car doesn't move in the direction(s) you expect, you will need to change the initialization block until the car moves correctly.</p> <p>Challenge</p> <p>Can you make the car travel in a square, ending up where it started?</p>"},{"location":"makerpi/optumbot/readUART/","title":"Reading from the UART","text":""},{"location":"makerpi/optumbot/readUART/#add-a-bluetooth-module-to-your-chassis","title":"Add a bluetooth module to your chassis","text":"<p>Once you added the module, build the blocks to initialize the uart and display the data that you sent to the module.  Note that the bluetooth module is connected to UART on Port 1 with a baudrate of 9600 baud.  You'll need to use software on you phone, tablet or computer to send data to the bluetooth module.  If you are using LightBlue, open the application and find the bluetooth module.  Selecting the module will take you to the next screen with device information.  Selecting the Characteristic section will allow you to write to the module.  Change the data type from Hex to UTF-8.  Then write a new value and send it.</p> <p></p>"},{"location":"makerpi/optumbot/readUART/#now-add-the-motor-control","title":"Now add the motor control","text":"<p>Once again, add the motor control.  Now make the car move forward and stop as you send commands to the module.</p> <p></p> <p>Challenge</p> <p>Can you make the car travel in other directions?</p>"},{"location":"pico/01-intro/","title":"Introduction to using a Raspberry Pico with BIPES","text":"<p>These lessons assume that you have at least skimmed the Getting Started sections and have selected the Raspberry Pi Pico in BIPES to write your code.</p> <p>The lessons will introduce you to using BIPES with the Raspberry Pi Pico.</p> <p>The Pico (shown below) has 28 general purpose (GP) pins.  Those pins can be used for a variety of functions.  We will be exploring thos functions in the subsequent labs.</p> <p></p> <p>The first example just uses the Raspberry Pi Pico and its internal LED. All the subsequent examples will require you to place components on a solderless breadboard.</p>"},{"location":"pico/actuators/servo/","title":"Controlling a Servo Motor with BIPES","text":""},{"location":"pico/actuators/servo/#types-of-servos","title":"Types of Servos","text":"<p>Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use:</p> <ol> <li>SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4</li> <li>MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5</li> </ol> <p>There are other variations that have 360 degree or continuous rotation servos.</p>"},{"location":"pico/actuators/servo/#servo-connections","title":"Servo Connections","text":"<p>Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards.</p> <ol> <li>Ground (black or brown wire)</li> <li>5 volt power (always red)</li> <li>Data (orange or yellow)</li> </ol>"},{"location":"pico/actuators/servo/#a-set-of-blocks-used-to-rotate-180-degrees-90-through-90","title":"A set of blocks used to rotate 180 degrees (-90 through 90)","text":""},{"location":"pico/actuators/servo/#references","title":"references","text":"<ol> <li>SparkFun Servos Page</li> <li>SparkFun Category for Servos</li> <li>eBay Servo Plastic Servo</li> <li>eBay Servo Metal Gear Servo</li> </ol>"},{"location":"pico/basics/blink/","title":"Blink in BIPES","text":""},{"location":"pico/basics/blink/#overview","title":"Overview","text":"<p>In this lab, we will use BIPES to make the green on-board LED on the Raspberry Pi Pico blink on and off every half second.  The only things you need to run this program are</p> <ol> <li>BIPES</li> <li>a USB cable</li> <li>a Raspberry Pi Pico microcontroller</li> </ol>"},{"location":"pico/basics/blink/#finding-the-blocks","title":"Finding the Blocks","text":"<p>Take a look at the left navigation.  Each section in the navigation contains different items that you will use to run your program.  We will use blocks from Loops, </p> <p> </p> <p>Logic,</p> <p> </p> <p>Machine:In/Out Pins (Change the pin to LED / GPIO25),</p> <p> </p> <p>and Timing (Change the delay time to .5) sections.</p> <p> </p>"},{"location":"pico/basics/blink/#blinking-the-builtin-led","title":"Blinking the Builtin LED","text":"<p>The pico has a single built in green LED wired to logical pin 25.  We call this GPIO 25.  GPIO means General Purpose Input and Output pin. Here is a sample program that you can use.  Don't worry about understanding each block yet.  We will cover the various parts in later sections.</p> <p></p> <p>Anything inside the green block repeats while true. Thus the program will run forever, or until we stop it.  We are setting the onboard LED to true (on).  The next block is a delay for 1/2 second.  We repeat those two blocks, this time setting the onboard LED to false (off).</p>"},{"location":"pico/basics/blink/#changing-the-blink-speed","title":"Changing the Blink Speed","text":"<p>Next, lets create a variable from the Variable navigation section for the delay that the LED is on and off.   Click on the Create variable... block to create a variable named delay. </p> <p> </p> <p>Once the delay variable is created, new blocks will be created in the Variable navigation section</p> <p> </p> <p>The number in the delay block comes from the Math navigation section.</p> <p> </p> <p>Now we can change the blink speed easily, by only changing the value of the delay variable.</p> <p></p> <p>This program will blink the built-in LED on and off every 1/4 of a second.  By changing the delay variable you can make the LED blink faster and slower.</p> <p>Challenge</p> <p>What is the fastest you can make the LED blink and still see it changing?  What does this tell you about the human eye?</p>"},{"location":"pico/basics/blinkExternal/","title":"Blinking external LEDs","text":"<p>Although the builtin LED is convenient, you can use the code to blink any number of external LEDs that are connected through a 330 ohm resister in series to the LED.</p> <p>We will need to use the breadboard for this lab.  If the Pico isn't already inserted into the breadboard, do so now.  Pin 1 (Top left pin) should be inserted into c1 of the breadboard.</p> <p>Hints:</p> <ul> <li>We will assume that LEDs are connected to pins GPIO16 and GPIO17 and are connected via a 330 ohm resistor to ground.</li> <li>The longer lead on the LED is the Anode (+) lead, connect it to the GPIO pins on the Pico</li> <li>Modify the first program</li> <li>Note which GPIO pins are connected to each LED.  They should be the two bottom pins on the right side.</li> </ul> <p></p> <p>Here are the blocks that will blink the LEDs that are connected to GPIO16 &amp; GPIO17 10 times, then turn off the remaining lit LED.  Note that we are using a different loop block from the Loops navigation section.  This loop block allows us to determine a set number of times that the code inside the loop will be executed.</p> <p></p> <p>Challenge</p> <p>Can you use a List with a Loop and Logic to make a set of 4 LEDS blink in sequence?</p> <p>Hints:</p> <ul> <li>Create a List block with the pins that connect to the LEDs.  Note: You can use the settings gear  to change the number of list items.</li> </ul> <p></p> <ul> <li>Use the \"for each item in list\" Loop block to select the LED to turn on</li> </ul> <p></p> <ul> <li>Use a second \"for each item in list\" Loop block with a conditional Logic block to turn off the other LEDs</li> </ul> <p></p>"},{"location":"pico/basics/button/","title":"Button","text":"<p>In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano.  We will use it to toggle the built-in LED.  We will start out with simply polling the button 10 times a second to check it's state.  Then we will show how to use an interrupt handler function to monitor events from the button.</p> <p></p> <p>In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico.  This is GPIO Pin 15 and is in row number 20 of our breadboard.</p>"},{"location":"pico/basics/button/#momentary-switch-buttons","title":"Momentary Switch Buttons","text":"<p>We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards.  When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side.  The buttons can be mounted directly over the trough in the center of the breadboard.  They typically cost under $2 for 10 buttons or about 20 cents per button.</p> <p> Here are the internal connections within the switch.</p> <p> This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico.  This corresponds to GP15 or Pin #15 in our code.</p>"},{"location":"pico/basics/button/#sample-button-polling-code","title":"Sample Button Polling Code","text":"<p>Here is our fist example that uses a simple \"watching\" loop to check if the button value has changed 10 times per second.  In this case, the built-in LED is connected to pin 25.</p> <p></p>"},{"location":"pico/basics/button/#interrupt-handler-version","title":"Interrupt Handler Version","text":"<p>Although the polling version is simple, it does take a lot of the CPU resources.  The button.value() is checked 10 times a second, even though the button might only be pressed once a day!</p> <p>A more efficient version uses a strategy called an interrupt handler.  This is a function that is \"registered\" by micropython to handle external events such as a button press.</p> <p></p> <p>You can see the count of button presses in the console.</p>"},{"location":"pico/basics/button/#interrupt-handler-with-a-debounce-feature","title":"Interrupt Handler with a Debounce Feature","text":"<p>One of the problems with most switches is that they don't turn on and off perfectly each time.  As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds.  So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open.  This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing.</p> <p></p> <p>To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code.</p> <p>The secret is to setup a timer when the switch is first closed or opened.  We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds).  By then we usually have a solid indication that the button is changing state and we can return the new value.</p> <p>Here are the blocks of this \"Debounce\" code:</p> <p></p>"},{"location":"pico/basics/button/#references","title":"References","text":"<ol> <li>Raspberry Pi Pico Getting Started Guide Lab 6</li> <li>YouTube Video</li> <li>Sample eBay List of Switches with trough pins</li> <li>Sample B3F Button on eBay 10 pieces for $1.50</li> </ol>"},{"location":"pico/basics/fadeInAndOut/","title":"Fade an LED in and Out","text":"<p>In the prior Blink lab, we turned an LED on an off at different speeds.  But what if we want to slowly turn on our LED on and off?  In this lab we will show you how to dim your LED to any brightness level you want.</p>"},{"location":"pico/basics/fadeInAndOut/#welcome-to-pulse-width-modulation","title":"Welcome to Pulse Width Modulation","text":"<p>Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits.  But there is an easier way to adjust the brightness of an LED!  We can quickly turn the signal to the LED on and off.  We can do this so quickly that you can't even see it flicker.  Controlling the amount of time a signal is on is all about controlling the width of the ON pulse.  That is why this is called Pulse Width Modulation or PWM for short.</p> <p>With a PWM design there are two things we need to tell the microcontroller:</p> <ol> <li>How often do you want a square wave to go on and off?  The rate of change of the pulse is called the frequency.</li> <li>How wide should the on part of the pulse be (relative to the total width).  This is called the duty cycle.</li> </ol> <p>A GPIO pin is declared a PWM output when you use the PWM block found in the Machine: In/Out Pins navigation section.  The block initializes a pin to be a PWM pin.  Frequency and duty cycle can then be set individually.  Conversly, the RPI PWM block lets you set both the frequency and duty cycle when the pin is initalized.</p> <p>Note that we can slow the frequency way down and the dimming effect will still work.  As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on.</p> <p>Here is the sample program that will slowly dim the builtin LED that is on pin 25:</p> <p></p> <p>Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on).  It then does the reverse and slowly dims the LED and then repeats.  There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again.</p>"},{"location":"pico/basics/fadeInAndOut/#suggested-exercises","title":"Suggested Exercises","text":"<ol> <li>Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10.  When can you just barley see it flicker?  What does this tell you about the human eye?</li> <li>Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again?</li> <li>Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second?</li> <li>What lights in your home would you like to see slowly dim on and off?  How could you modify a light (safely) so that it slowly dimmed on and off.  Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down?</li> <li>Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)?</li> <li>When you stop the program does the LED stop changing brightness?  Does it retain the value that it had when you pressed the Stop function?  What does that tell you about how main CPU and the role of PWM? </li> </ol>"},{"location":"pico/basics/fadeInAndOut/#references","title":"References","text":""},{"location":"pico/basics/fadeInAndOut/#pulse-with-modulation","title":"Pulse With Modulation","text":"<ol> <li>Wikipedia Article on Pulse With Modulation</li> </ol>"},{"location":"pico/basics/potentiometer/","title":"MicroPython Potentiometer Lab","text":"<p>In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code.  We will show how we can use a potentiometer to change the blinking speed of on LED.</p>"},{"location":"pico/basics/potentiometer/#about-analog-to-digital-converters","title":"About Analog to Digital Converters","text":"<p>Digital microcontrollers are inherently noisy.  They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines.  This makes it difficult to get </p> <p>ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin.</p>"},{"location":"pico/basics/potentiometer/#circuit-diagram","title":"Circuit Diagram","text":"<ol> <li>Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin.</li> <li>Connect the center tap to row 10 which is ADC0</li> <li>Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin</li> </ol> <p>Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins.  These are special pins designed to reduce the noise on the power areas of the pico.</p>"},{"location":"pico/basics/potentiometer/#sample-set-of-blocks-to-print-potentiometer-values","title":"Sample set of blocks To Print Potentiometer Values","text":"<pre><code>graph LR\np[Pico]--&gt;|ADC_VREF 36 row=6| pos(Positive)\np[Pico]--&gt;|AGND 33 row=8| neg(Negative)\np[Pico]--&gt;|GP26 pin=26 ADC0 31 row=10| tap(Center Tap)\n    pos(Positive) --- pot(Potentiometer)\n    neg(Negative) --- pot(Potentiometer)\n    tap(Center Tap) --- pot(Potentiometer)\n</code></pre> <p>Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard).  The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.</p>"},{"location":"pico/basics/potentiometer/#changing-blink-speed-with-a-potentiometer","title":"Changing Blink Speed with a Potentiometer","text":"<p>The following video shows this script in action.</p>"},{"location":"pico/basics/potentiometer/#changing-the-brightness-of-the-built-in-led","title":"Changing the Brightness of the Built in LED","text":"<p>We can change the brightness of the builtin LED by using the POT value to change the PWM duty cycle.</p> <p>Here is a sample set of blocks that does this:</p> <p></p>"},{"location":"pico/displays/neopixel/","title":"NeoPixels","text":"<p>NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line.  They are very popular with our students because they are powerful, easy to program and full of bling.</p> <p>Note</p> <p>As of March of 2022 there is now built-in support for NeoPixels in the MicroPython 1.18 runtime for the Raspberry Pi RP2040 microcontroller.  Although you can still use custom libraries, this tutorial assumes you are using version 1.18 or later.</p> <p>Controlling NeoPixels is challenging since the timing of data being sent must be very precise.  Python alone is not fast enough to send bits out of a serial port.  So a small function that uses assembly code is used.  This code can be called directly from a neopixel driver file so that the user's don't need to see this code.</p> <p>MicroPython Example Code on ESP8266</p>"},{"location":"pico/displays/neopixel/#different-types-of-neopixels","title":"Different Types of NeoPixels","text":"<p>There are many different types of NeoPixels.  They come in many forms such as strips, rings and matrices.</p> <p></p> <p>The most common type of NeoPixels are strips.  The strips come in a variety of densities and waterproofing.  The most common and easiest to use are the 60 pixels-per-meter type.</p>"},{"location":"pico/displays/neopixel/#circuit-connections","title":"Circuit connections","text":"LED Strip Pico Name Pico Pin Description GND GND 38 Ground 5v VBUS 40 Voltage from the USB bus.  Top right with USB on top Data GP0 0 Row 1 on the left side <p>Note that you can also power most of the LED strips using the 3.3 volts available on Grove connectors.  The only difference is the brightness might not be quite as high, but for most applications this will not be a problem.</p>"},{"location":"pico/displays/neopixel/#setup-parameters","title":"Setup Parameters","text":"<p>Our block will have two parts:</p> <ol> <li>Initialization of the NeoPixel object using the static block parameters.  This is also done just once.</li> <li>Sending the drawing commands to the device through the data port.  This is usually done within a main loop.</li> </ol>"},{"location":"pico/displays/neopixel/#sample-programs","title":"Sample Programs","text":"<p>Now we are ready to write our first small test program!</p>"},{"location":"pico/displays/neopixel/#move-red-pixel-across-strip","title":"Move Red Pixel Across Strip","text":""},{"location":"pico/displays/neopixel/#fade-in-and-out","title":"Fade in and Out","text":"<p>Make the first pixel fade the red color in and out.  We do this by slowly turning up the color level of the red on the NeoPixel.</p> <p>We start a 0 and go up to 255.  Then we go back from 255 back down to zero.  We delay about 5 milliseconds between each of the 255 brightness levels.</p> <p></p>"},{"location":"pico/displays/neopixel/#heartbeat-lab","title":"Heartbeat Lab","text":"<p>What if you were building a robot and you wanted to flash the LED to look like a human heartbeat?  Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart.  This is called an electro cardiogram (EKG) and it look like this:</p> <p></p> <p>Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down.  When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values.  The eye can't usually see the intermediate brightness values if the brightness is changing quickly.  To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255.</p> <p>The following blocks emulate this heart beat pattern:</p> <p></p>"},{"location":"pico/displays/neopixel/#move-red-green-and-blue","title":"Move Red, Green and Blue","text":"<p>The following program will just take the blocks in the loop above and move it into a function, then call the function with red, blue, and  green.</p> <p></p>"},{"location":"pico/displays/neopixel/#rainbow-cycle","title":"Rainbow Cycle","text":"<p>The program cycles each pixel through all the colors in a rainbow.  It uses two functions:</p> <ol> <li>wheel(pos) this function takes a position parameter from 0 to 255 and returns a triple of numbers for the red, green and blue values as the position moves around the color wheel.  This is a handy program anytime you want to cycle through all the colors of the rainbow!</li> <li>rainbow_cycle will cycle each of the pixels in a strip through the color wheel.  It gives the appearance that colors are moving across the strip.  The wait is the delay time between updating the colors.  A typical value for wait is .05 seconds or 50 milliseconds.</li> </ol> <p></p>"},{"location":"pico/displays/neopixel/#references","title":"References","text":"<ul> <li>MicroPython RP2 Reference for NeoPixel Driver</li> <li>Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video</li> <li>MicroPython Library for NeoPixel (used before version 1.18 of the MicroPython RP2 Runtime) - note the lack of support for the RP2040 microcontroller.</li> <li>rp2 port no module named array</li> <li>For additional NeoPixel projects, check out the Moving Rainbow Site</li> </ul>"},{"location":"pico/displays/ssd1306/","title":"OLED SSD1306 Examples","text":""},{"location":"pico/displays/ssd1306/#using-the-ssd1306-with-i2c-interfaces","title":"Using the SSD1306 with I2C Interfaces","text":""},{"location":"pico/displays/ssd1306/#hello-world","title":"Hello World","text":"<p>After this program runs you should see the text on your OLED display. </p>"},{"location":"pico/displays/ssd1306/#counter-example","title":"Counter Example","text":"<p>In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh.  A counter will cycle from 1 to 50.</p> <p></p>"},{"location":"pico/displays/ssd1306/#animated-box","title":"Animated Box","text":"<p>This draws a title and four lines around a drawing area.  It then draws boxes that move to the right.</p> <p></p>"},{"location":"pico/displays/ssd1306/#references","title":"References","text":"<ol> <li> <p>MicroPython Tutorial on the SSD1306</p> </li> <li> <p>M Fitzp OLED Display i2c Article</p> </li> <li> <p>Adafruit Stats</p> </li> <li> <p>DIY More OLED Product Description</p> </li> <li> <p>Using I2C Defaults</p> </li> </ol>"},{"location":"pico/music/tunes/","title":"Introduction to Sound and Music in MicroPython","text":""},{"location":"pico/music/tunes/#how-microcontrollers-generate-sound","title":"How Microcontrollers Generate Sound","text":"<p>Microcontrollers are really great at generating digital outputs on their GPIO pins.  These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts.  However, they are not designed to create \"analog\" output of a continuous varying voltage.  However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs.</p> <p>Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals.  By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch.</p> <p>MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes.  This is called the PWM library.  Will will use this in our sound and music programs.  Here is a sample of how this is called in our code:</p>"},{"location":"pico/music/tunes/#duty-cycle","title":"Duty Cycle","text":"<p>The Duty Cycle is what percent of time a pulse is high.</p> <p></p> <p>For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time.  So our duty cycles will be set to be 50%.  Fortunately, BIPES take care of this for us.  Playing sounds is as simple as loading the rtttl library.  If you are looking to play a song, load the songs as well, then play your tunes.  See the sample block below.</p> <p></p>"},{"location":"pico/music/tunes/#connecting-a-sound-device","title":"Connecting a Sound Device","text":"<p>There are several different ways that you can connect a sound device to you MicroController.  Here are three options:</p> <ol> <li>Buzzers - These are small inexpensive devices that can mount directly on your breadboard.</li> <li>Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker</li> <li>Speaker - A magnetic speaker with our without an amplifier is another way to hear sound.  You can also purchase a small amplifier to increase the volume.</li> <li>Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board</li> </ol> <p> </p>"},{"location":"pico/music/tunes/#references","title":"References","text":"<p>https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba</p>"},{"location":"pico/sensors/dht11Sensor/","title":"Sensing Temperature and Humidity with the DHT11 Sensor","text":""},{"location":"pico/sensors/dht11Sensor/#sample-blocks","title":"Sample Blocks","text":""},{"location":"pico/sensors/dht11Sensor/#references","title":"References","text":"<ul> <li>Peppe80's Example</li> <li>Axel \u00d6rn Sigur\u00f0sson's DHT11 Driver</li> </ul>"},{"location":"pico/sensors/mpu6050Sensor/","title":"MPU-6050 Accelerometer Gyroscope Temperature","text":"<p>MPU6050 is a Micro Electro-mechanical system (MEMS), it consists of three-axis accelerometer and three-axis gyroscope. It helps us to measure velocity, orientation, acceleration, displacement and other motion like features.</p> <p>(Gyro + Accelerometer) MEMS MotionTracking\u2122 Device</p> <ul> <li>How the MPU6050 works</li> </ul>"},{"location":"pico/sensors/mpu6050Sensor/#pinouts","title":"Pinouts","text":"<ol> <li>VIN: Voltage Supply Pin</li> <li>GND: 0V Power Supply</li> <li>SCL: I2C Clock Input</li> <li>SDA: I2C Data Input</li> <li>XDO: I2C Data Output</li> <li>XCL: I2C Clock Output</li> <li>ADO: Determines the I2C address of the module</li> <li>INT: Interrupt Output</li> </ol> <p>You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA.  The other connections are not needed.</p>"},{"location":"pico/sensors/mpu6050Sensor/#mpu6050-drivers-and-sample-blocks","title":"MPU6050 Drivers and sample blocks","text":"<p>Make sure to load two libraries, the imu library and the vector3d library</p> <p></p>"},{"location":"pico/sensors/photoSensor/","title":"Light Sensor with Raspberry Pi Pico with BIPES","text":"<p>A photoresistor is a sensor that decreases resistance when light is shined on its surface.  With no light a photoresistor has high resistance in the range of megaohms.  As light shines on the surface the resistance drops to kiloohms.  We can use this effect as a light sensor.</p> <p>To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor.  We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor.  The top and bottom of the circuit are tied to ground and a power rail.  This will move the voltage of the midpoint of the circuit.</p> <p></p>"},{"location":"pico/sensors/photoSensor/#circuit","title":"Circuit","text":"<p>We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor.  Using other power and ground pins will work, but power fluctuations will make the result noisy. </p>"},{"location":"pico/sensors/photoSensor/#sample-blocks","title":"Sample Blocks","text":"<p>Our program will first use the Analog to Digital Circuit (ADC0) as an input.  On the Pico this is on pin 26.</p> <p></p> <p>When you run the program a series of print values is displayed in the console every 1/5th of a second.  Look to see how the numbers change as you cover and uncover detector from a light source.</p>"},{"location":"pico/sensors/photoSensor/#experiments","title":"Experiments","text":"<ol> <li>What types of devices could use a light detector?</li> <li>How does a night-light work?  How could you add an LED to the circuit so that the LED would turn on if the light level got too low?</li> <li>Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room?  What would that code look like?</li> </ol>"},{"location":"pico/sensors/photoSensor/#references","title":"References","text":"<ol> <li>Wikipedia Page on Photoresistor</li> </ol>"},{"location":"pico/sensors/pingSensor/","title":"Ultrasound Ping Sensor","text":"<p>The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it.</p>"},{"location":"pico/sensors/pingSensor/#wiring-diagram","title":"Wiring Diagram","text":"<ol> <li>Connect GND to any GND pin on the Pico</li> <li>Connnect VCC to VBUS or 5 Volt power</li> <li>Connect Trigger to pin 15.  With USB on the top, this pin is the bottom left corner.</li> <li>Connect Echo to pin 14.  One up from bottom left corner.</li> </ol>"},{"location":"pico/sensors/pingSensor/#sample-blocks","title":"Sample Blocks","text":"<p>The Ultrasound Ping sensor is found in the left navigation Sensors: Ultrasound.  Make sure to load the library for the sensor</p> <p></p>"},{"location":"picoW/01-intro/","title":"Introduction to Networking with MicroPython and the Raspberry Pi Pico W","text":"<p>These lessons are designed to give students an understanding of how wireless communications work with MicroPython.</p>"},{"location":"picoW/01-intro/#raspberry-pi-pico-w","title":"Raspberry Pi Pico W","text":"<p>One June 30th, 2022 the Raspberry Pi Foundation announced the availability of the Raspberry Pi Pico W.  This $6 microprocessor now supports WiFi and with a software upgrade it may soon support Bluetooth.</p> <p>The Pico W supports 2.4 Ghz 802.11n wireless networking.  For MicroPython, we can use a MicroPython library built around the lwip TCP/IP stack.  This stack is accessible using the MicroPython network functions.</p> <p>The WiFi chip used is the Infineon CYW43439 chip.  This chip also uses an ARM architecture and has extensive support for Bluetooth wireless communication.</p> <p></p> <p>You can read more about the capabilities of the WiFi/Bluetooth chip by reading the Infineon CYW43439 Datasheet.  It is interesting that the CYW43439 chip has 512KB of SRAM - almost double what the RP2040 chip contains!</p>"},{"location":"picoW/connect/","title":"Connecting to a WiFi Network","text":"<p>Make sure to fill in your network name and password to connect to your WiFi Network.  Then take a look at the console to see the address of the Pico W once it connects to your network.</p> <p></p>"},{"location":"picoW/connect/#check-the-console-for-your-connection-details","title":"Check the console for your connection details","text":"<p>The first part of the connection string is the IP Address of the board.  Next is the network mask, and then the network gateway.  We can ignore everything after the IP Address.  </p> <p></p>"},{"location":"picoW/connect/#ping-the-pico-w","title":"Ping the Pico W","text":"<p>Once the connection is up and running, you can open a console window and ping your Pico W (assuming you are on the same network)</p> <p></p>"},{"location":"picoW/httpGet/","title":"Getting data from an online API","text":""},{"location":"picoW/httpGet/#working-with-http-get","title":"Working with HTTP GET","text":"<p>This sample was modified from an example on Tom's Hardware</p> <p>The API call returns a json response.  Unfortunately, BIPES can't process a json, response, so we will have to create a small Python routine to convert the response into a list we can work with.</p>"},{"location":"picoW/httpGet/#the-call-and-response","title":"The Call and Response","text":"<p>Open a web browser and put the following in as the address: http://api.open-notify.org/astros.json.  The json response may be different, depending on when you try it; however, at this time there are 14 astronauts in space as shown in the response:</p> <p></p> <p>Fortunately, BIPES has the capability that allows us to run Python code within our blocks.  In this case, we can create a small function to create a list from the json response.  First, convert the response into a json object.  Then extract the number of astronauts on the object.  Finally, create a list of of astronauts and return the list.</p> <p></p> <p>Now, lets get the data by connecting to our WiFi network, using the HTTP Get request block, calling our newly created function, and printing the results to the console.  Don't forget to add your WiFi network name and password!</p> <p></p> <p>You can see the results in the console window</p> <p></p>"},{"location":"picoW/starWars/","title":"TCP/IP Socket Connect","text":""},{"location":"picoW/starWars/#what-is-a-tcpip-socket-connection","title":"What is a TCP/IP Socket Connection?","text":"<p>A socket programming interface provides the routines required for interprocess communication between applications, either on the local system or spread in a distributed, TCP/IP based network environment. Once a peer-to-peer connection is established, a socket descriptor is used to uniquely identify the connection. The socket descriptor itself is a task specific numerical value.</p>"},{"location":"picoW/starWars/#lets-watch-star-wars","title":"Lets watch Star Wars!","text":"<p>Using our WiFi connection and our Pic oW, we can use BIPES to connect to a site that will show Star Wars: The New Hope as ASCII art.  We'll connect to the site towel.blinkenlights.nl on Port 23.  Then we will read data from the site and display the data in the console.  Sit back, relax, and enjoy the movie after entering your WiFi network name and password using the following blocks:</p> <p></p> <p>R2-D2 and C3PO as ASCII art in the movie</p> <p></p>"},{"location":"picoW/webServer/","title":"Creating a Web Server in BIPES","text":"<p>These blocks will turn the Pico W into a small webserver.  The web page has two links in it, one to turn the internal LED on, the other to turn it off.  Make sure to fill in your network name and password to connect to your WiFi Network.  Then take a look at the console to see the address of the webserver once the webserver starts.</p>"},{"location":"picoW/webServer/#web-server-blocks","title":"Web Server Blocks","text":""},{"location":"picoW/webServer/#check-the-console","title":"Check the Console","text":"<p>Take a look at the console to see the address of the webserver once the webserver starts. </p> <p></p> <p>Try the \"Soft reset device\" button on the console if you get an ENOMEM error when the web server connects. </p>"},{"location":"picoW/webServer/#open-a-browser-and-enter-the-address-of-the-server","title":"Open a browser and enter the address of the server","text":"<p>Make sure your device is on WiFi!  If you are using your phone, turn off cellular before trying to connect. You should see the following web page:</p> <p></p> <p>Click on Turn On to turn on the internal LED.  Click on Turn Off to turn it off.  It may take a few moments after clicking to see the page render and the LED react.  Be Patient!</p> <p>Challenges</p> <p>The Pico W shares many of the same pins as the Pico.</p> <ul> <li> <p>Can you use one of the GPIO pins to turn on and off an external LED?</p> </li> <li> <p>Can you use one of the ADC pins to read and display a voltage?</p> </li> <li> <p>Can you use a display and send a message?</p> </li> </ul>"}]}