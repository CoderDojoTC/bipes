{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BIPES Block Programming with MicroPython BIPES Block Programming with MicroPython Block-based Integrated Platform for Embedded Systems (BIPES), an open source project developed in partnership with a range of universities to develop a drag-and-drop visual programming environment for the embedded world, has support for the Raspberry Pi Pico and its RP2040 microcontroller. BIPES has been extended to add support for the Raspberry Pi Pico W as well as the Maker Pi RP2040 based Optum Bot. Read more about the history of BIPES here","title":"BIPES Home"},{"location":"#bipes-block-programming-with-micropython","text":"BIPES Block Programming with MicroPython Block-based Integrated Platform for Embedded Systems (BIPES), an open source project developed in partnership with a range of universities to develop a drag-and-drop visual programming environment for the embedded world, has support for the Raspberry Pi Pico and its RP2040 microcontroller. BIPES has been extended to add support for the Raspberry Pi Pico W as well as the Maker Pi RP2040 based Optum Bot. Read more about the history of BIPES here","title":"BIPES Block Programming with MicroPython"},{"location":"contacts/","text":"BIPES Contacts Jim Tannenbaum (aka \"JET\") Dan McCreary","title":"Contacts"},{"location":"contacts/#bipes-contacts","text":"Jim Tannenbaum (aka \"JET\") Dan McCreary","title":"BIPES Contacts"},{"location":"contributing/","text":"Contributing We welcome anyone that has sample lesson plans they would like to contribute. You can use the following ways to contribute: Submit a pull request Add an issue to our issue tracker Send one of us your sample lesson plans or code via e-mail. You can see our contacts on the Contacts page. Authoring Guidelines This site is built using Markdown, GitHub Pages and mkdocs using the mkdocs-material theme. See our authoring guidelines for further details: Content Authoring Guide","title":"Contributing"},{"location":"contributing/#contributing","text":"We welcome anyone that has sample lesson plans they would like to contribute. You can use the following ways to contribute: Submit a pull request Add an issue to our issue tracker Send one of us your sample lesson plans or code via e-mail. You can see our contacts on the Contacts page.","title":"Contributing"},{"location":"contributing/#authoring-guidelines","text":"This site is built using Markdown, GitHub Pages and mkdocs using the mkdocs-material theme. See our authoring guidelines for further details: Content Authoring Guide","title":"Authoring Guidelines"},{"location":"glossary/","text":"BIPES Glossary Here is a glossary of terms we use in these courses. BIPES Block-based Integrated Platform for Embedded Systems BIPES was originally developed by Rafael Aroca . He has been etremely generous in allowing me to \"play in his backyard.\" Any errors in this implementation of BIPES are my fault -- Jet Raspberry Pi Pico A low-cost $4 microcontroller that you can program with BIPES. Maker Pi RP2040 A low-cost $10 development board based on the Raspberry Pi microcontroller chip that you can program with BIPES.","title":"Glossary"},{"location":"glossary/#bipes-glossary","text":"Here is a glossary of terms we use in these courses.","title":"BIPES Glossary"},{"location":"glossary/#bipes","text":"Block-based Integrated Platform for Embedded Systems BIPES was originally developed by Rafael Aroca . He has been etremely generous in allowing me to \"play in his backyard.\" Any errors in this implementation of BIPES are my fault -- Jet","title":"BIPES"},{"location":"glossary/#raspberry-pi-pico","text":"A low-cost $4 microcontroller that you can program with BIPES.","title":"Raspberry Pi Pico"},{"location":"glossary/#maker-pi-rp2040","text":"A low-cost $10 development board based on the Raspberry Pi microcontroller chip that you can program with BIPES.","title":"Maker Pi RP2040"},{"location":"intro/01-intro/","text":"An introduction to BIPES What is BIPES BIPES (Block based Integrated Platform for Embedded Systems) allows text and block based programming for several types of embedded systems and Internet of Things modules using MicroPython. You can connect, program, debug and monitor several types of boards using a serial USB connection. Why BIPES is Fun BIPES hides the complexity of MicroPython by allowing users to program microcontrollers via an easy to use graphical interface. BIPES has several built in libraries that make adding accessories to your microcontroller simple. The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts. About this site This site provides a rich collection of resources to teach computational thinking to students from 10 to 16 years old using fun programs that control the physical world around us. The sub-field of computer science that reads sensors and controls lights and motors is called Physical Computing. You can read about physical computing on our MicroPython site. Want to learn more? This site will concentrate on using BIPES to program the Raspberry Pi Pico and the Cytron Maker Pi 2040 boards. The lessons are based, in part, on the MicroPython lessons covered in our MicroPython for Kids site. A discussion of how a breadboard works , different types of microcontrollers , and the Raspberry Pi Pico are all covered on that site.","title":"About BIPES"},{"location":"intro/01-intro/#an-introduction-to-bipes","text":"","title":"An introduction to BIPES"},{"location":"intro/01-intro/#what-is-bipes","text":"BIPES (Block based Integrated Platform for Embedded Systems) allows text and block based programming for several types of embedded systems and Internet of Things modules using MicroPython. You can connect, program, debug and monitor several types of boards using a serial USB connection.","title":"What is BIPES"},{"location":"intro/01-intro/#why-bipes-is-fun","text":"BIPES hides the complexity of MicroPython by allowing users to program microcontrollers via an easy to use graphical interface. BIPES has several built in libraries that make adding accessories to your microcontroller simple. The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts.","title":"Why BIPES is Fun"},{"location":"intro/01-intro/#about-this-site","text":"This site provides a rich collection of resources to teach computational thinking to students from 10 to 16 years old using fun programs that control the physical world around us. The sub-field of computer science that reads sensors and controls lights and motors is called Physical Computing. You can read about physical computing on our MicroPython site.","title":"About this site"},{"location":"intro/01-intro/#want-to-learn-more","text":"This site will concentrate on using BIPES to program the Raspberry Pi Pico and the Cytron Maker Pi 2040 boards. The lessons are based, in part, on the MicroPython lessons covered in our MicroPython for Kids site. A discussion of how a breadboard works , different types of microcontrollers , and the Raspberry Pi Pico are all covered on that site.","title":"Want to learn more?"},{"location":"intro/02-getting-started/","text":"Getting Started Before getting started with BIPES, follow the directions below to setup your microcontroller. Setup However, before getting started with BIPES, your microcontroller board must be setup. Regardless of which board you are using, you should start by doing the following steps: Download the flash_nuke.utf file to your computer. Download the latest MicroPython utf file to your computer. Hold down the BOOTSEL button on the Pico or the BOOT button on the Maker Pi then connect your microcontroller board to your computer with a micro usb cable and it will appear as a drive onto which you can drag the flash_nuke.uf2 file If you don't see the Maker Pi board, make sure the on/off switch is in the on position before connecting to your computer. Once the drive reappears, copy the MicroPython utf file to your device. If you are having trouble, take a look at the Drag-and-Drop MicroPython page Working with BIPES Working with BIPES is easy, since there is nothing to load on your computer. BIPES can be found online . Once the Welcome screen loads in your browser, you can do the following: Close the Welcome screen There are two configurations you must change. Your serial port and device. Connect to your device Serial connection On the Mac, the Pico will connect to a port in the /dev/ directory such as: /dev/cu.usbmodem140101 - 1 - Select the comm port for your board Select your device: The Raspberry Pi Pico The Maker Pi RP2040 The left navigation pane contains all of the blocks you will need to run the examples for the Raspberry Pi Pico and the Maker Pi RP2040 microcontrollers. Using the BIPES Drag and Drop Interface Adding a loop Test Your Connection The best way to test your connection is to write a small program that will flash the on-board LED. See the basic blink example under Raspberry Pi Pico. Congratulations! You are ready to start using BIPES.","title":"Getting Started"},{"location":"intro/02-getting-started/#getting-started","text":"Before getting started with BIPES, follow the directions below to setup your microcontroller.","title":"Getting Started"},{"location":"intro/02-getting-started/#setup","text":"However, before getting started with BIPES, your microcontroller board must be setup. Regardless of which board you are using, you should start by doing the following steps: Download the flash_nuke.utf file to your computer. Download the latest MicroPython utf file to your computer. Hold down the BOOTSEL button on the Pico or the BOOT button on the Maker Pi then connect your microcontroller board to your computer with a micro usb cable and it will appear as a drive onto which you can drag the flash_nuke.uf2 file If you don't see the Maker Pi board, make sure the on/off switch is in the on position before connecting to your computer. Once the drive reappears, copy the MicroPython utf file to your device. If you are having trouble, take a look at the Drag-and-Drop MicroPython page","title":"Setup"},{"location":"intro/02-getting-started/#working-with-bipes","text":"Working with BIPES is easy, since there is nothing to load on your computer. BIPES can be found online . Once the Welcome screen loads in your browser, you can do the following: Close the Welcome screen There are two configurations you must change. Your serial port and device. Connect to your device Serial connection On the Mac, the Pico will connect to a port in the /dev/ directory such as: /dev/cu.usbmodem140101 - 1 - Select the comm port for your board Select your device: The Raspberry Pi Pico The Maker Pi RP2040 The left navigation pane contains all of the blocks you will need to run the examples for the Raspberry Pi Pico and the Maker Pi RP2040 microcontrollers.","title":"Working with BIPES"},{"location":"intro/02-getting-started/#using-the-bipes-drag-and-drop-interface","text":"","title":"Using the BIPES Drag and Drop Interface"},{"location":"intro/02-getting-started/#adding-a-loop","text":"","title":"Adding a loop"},{"location":"intro/02-getting-started/#test-your-connection","text":"The best way to test your connection is to write a small program that will flash the on-board LED. See the basic blink example under Raspberry Pi Pico. Congratulations! You are ready to start using BIPES.","title":"Test Your Connection"},{"location":"makerpi/01-intro/","text":"Introduction to using a Maker Pi RP2040 board with BIPES These lessons assume that you have at least skimmed the Getting Started sections and have selected the Maker Pi RP2040 in BIPES to write your code. It also assumed that you have worked through the examples for the Raspberry Pi Pico. The lessons will introduce you to using BIPES with the Maker Pi RP2040 board and the OptumBot. The first example uses the Maker Pi RP2040 and its internal LED in a similar manner to the exercise that was done with the Raspberry Pi Pico. The subsequent examples will repeat many of the previous examples, then add the unique capabilities of the Maker Pi RP2040.","title":"Introduction"},{"location":"makerpi/01-intro/#introduction-to-using-a-maker-pi-rp2040-board-with-bipes","text":"These lessons assume that you have at least skimmed the Getting Started sections and have selected the Maker Pi RP2040 in BIPES to write your code. It also assumed that you have worked through the examples for the Raspberry Pi Pico. The lessons will introduce you to using BIPES with the Maker Pi RP2040 board and the OptumBot. The first example uses the Maker Pi RP2040 and its internal LED in a similar manner to the exercise that was done with the Raspberry Pi Pico. The subsequent examples will repeat many of the previous examples, then add the unique capabilities of the Maker Pi RP2040.","title":"Introduction to using a Maker Pi RP2040 board with BIPES"},{"location":"makerpi/basics/blink/","text":"Blink in BIPES Overview In this lab, we will use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second. The only things you need to run this program are BIPES a USB cable a Maker Pi RP2040 microcontroller Blinking the Builtin LEDs The Maker Pi has thirteen built in blue LEDs wired to logical pins. Here is a sample program that you can use. It will blink each one of the LEDs in succession, up and down the board. Let's take a look at the blocks... The top left block creates the initial list, in sequence, running from GP0 to GP28 (one general purpose pin for each of the 13 LEDs). The block immediately below that creates a second list, in reverse order. On the right side, we set up a variable to control the amount of time between turning an LED on and turning it off. Then there is a loop that will run forever, or until we stop the program. Finally, inside the outer loop is two innner loops. The first walks through each LED, turning it on, waiting 1/4 second, then turning it off. The second loop does the same, moving the LEDs on and off in the reverse order. Notice that we have to convert the pin numbers in the second list to integers, since the list was initialized with a string. Changing the Blink Speed This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LEDs blink faster and slower. Challenge What is the fastest you can make the LEDs blink and still see them changing? What does this tell you about the human eye?","title":"Blink"},{"location":"makerpi/basics/blink/#blink-in-bipes","text":"","title":"Blink in BIPES"},{"location":"makerpi/basics/blink/#overview","text":"In this lab, we will use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second. The only things you need to run this program are BIPES a USB cable a Maker Pi RP2040 microcontroller","title":"Overview"},{"location":"makerpi/basics/blink/#blinking-the-builtin-leds","text":"The Maker Pi has thirteen built in blue LEDs wired to logical pins. Here is a sample program that you can use. It will blink each one of the LEDs in succession, up and down the board. Let's take a look at the blocks... The top left block creates the initial list, in sequence, running from GP0 to GP28 (one general purpose pin for each of the 13 LEDs). The block immediately below that creates a second list, in reverse order. On the right side, we set up a variable to control the amount of time between turning an LED on and turning it off. Then there is a loop that will run forever, or until we stop the program. Finally, inside the outer loop is two innner loops. The first walks through each LED, turning it on, waiting 1/4 second, then turning it off. The second loop does the same, moving the LEDs on and off in the reverse order. Notice that we have to convert the pin numbers in the second list to integers, since the list was initialized with a string.","title":"Blinking the Builtin LEDs"},{"location":"makerpi/basics/blink/#changing-the-blink-speed","text":"This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LEDs blink faster and slower. Challenge What is the fastest you can make the LEDs blink and still see them changing? What does this tell you about the human eye?","title":"Changing the Blink Speed"},{"location":"makerpi/basics/buttons/","text":"Buttons, Interrupts, and Functions in BIPES Overview In this lab, we will continue to use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second. The only things you need to run this program are BIPES a USB cable a Maker Pi RP2040 microcontroller Creating a function to blink an LED We want ot take advantage of BIPES ability to allow us to define our own functions. So we will use that to create a function to turn an LED on, wait a predetermined amount of time (delay), then turn the LED off, and again wait that same time before return to the calling program. Creating sequence variables to control direction Next, let's create a pair of variables to determine which direction the LEDs will sequence, forwards or backwards. Initially, we don't want to have the LEDs blink at all, so we'll set the variables to false. Adding interrupts to capture button presses Then, we can set up a pair of interrupts to capture when a button is pressed on the Maker Pi board, indicating the direction to sequence the LEDs. The main loop And finally, the main loop. It is similar to the previous example; however, there are two added if blocks to determine the sequence direction. The entire set of blocks Putting it all together allows us to sequence the LEDs in one direction, once one button is pressed, then sequence in the opposition direction when the other button is pressed. Challenge Can you make the sequence change direction in the middle of a run, rather than waiting for the sequence to complete?","title":"Buttons, Interrupts, and Functions"},{"location":"makerpi/basics/buttons/#buttons-interrupts-and-functions-in-bipes","text":"","title":"Buttons, Interrupts, and Functions in BIPES"},{"location":"makerpi/basics/buttons/#overview","text":"In this lab, we will continue to use BIPES to make the blue on-board LEDs on the Maker Pi blink on and off every quarter second. The only things you need to run this program are BIPES a USB cable a Maker Pi RP2040 microcontroller","title":"Overview"},{"location":"makerpi/basics/buttons/#creating-a-function-to-blink-an-led","text":"We want ot take advantage of BIPES ability to allow us to define our own functions. So we will use that to create a function to turn an LED on, wait a predetermined amount of time (delay), then turn the LED off, and again wait that same time before return to the calling program.","title":"Creating a function to blink an LED"},{"location":"makerpi/basics/buttons/#creating-sequence-variables-to-control-direction","text":"Next, let's create a pair of variables to determine which direction the LEDs will sequence, forwards or backwards. Initially, we don't want to have the LEDs blink at all, so we'll set the variables to false.","title":"Creating sequence variables to control direction"},{"location":"makerpi/basics/buttons/#adding-interrupts-to-capture-button-presses","text":"Then, we can set up a pair of interrupts to capture when a button is pressed on the Maker Pi board, indicating the direction to sequence the LEDs.","title":"Adding interrupts to capture button presses"},{"location":"makerpi/basics/buttons/#the-main-loop","text":"And finally, the main loop. It is similar to the previous example; however, there are two added if blocks to determine the sequence direction.","title":"The main loop"},{"location":"makerpi/basics/buttons/#the-entire-set-of-blocks","text":"Putting it all together allows us to sequence the LEDs in one direction, once one button is pressed, then sequence in the opposition direction when the other button is pressed. Challenge Can you make the sequence change direction in the middle of a run, rather than waiting for the sequence to complete?","title":"The entire set of blocks"},{"location":"makerpi/optumbot/build/","text":"Building the OptumBot remote control car with the Maker Pi RP2040 The bot brain is the Maker Pi RP2040. The Maker Pi board makes building a bot simple, since it is a one board solution built around the RP2040. The board comes with a dual channel DC motor driver, four servo motor ports, seven grove ports, a piezo, and two multi color leds. Maker Pi RP2040 Information The parts kit includes: Description Part Chassis kit Maker Pi RP2040 HC-05 or AT-09 Bluetooth module Ultrasonic sensor and mount Additional parts (not included in the kit): Nuts, bolts, and spacers Wire ties to secure wires Four AA batteries USB Micro B Cable Two optional IR Sensors for line following Additional software required: Software capable of connecting to and writing to the bluetooth module (I'm using LightBlue) Assemble the chassis Place the Maker PI RP2040 board on the rear of the chassis as shown and mark the small holes that are in each corner. Make sure the back of the board is closer to the back of the chassis, since the motors will end up close to the front board mounts. Once the holes are marked, drill the holes, using an 1/8 inch drill bit. Be careful, as your mounting holes may be close to existing mount holes in the chassis. Also note that the chassis is thin plastic, so it must be supported as you drill through it. After the holes are drilled, remove the paper from the chassis, motor mounts, and sensor mount. All parts should be clear plastic after the paper is romoved. Gather the wheel, motor, mounts, long screws, and nut as shown above. Slide the motor mounts through the chassis, then insert and secure the motor with the screws. Note that the wires will seperate from the motor if not handled with care. The wires should be on the side of the motor that faces out from the chassis. Once the motor is mounted, feed the wires through the chassis and optionally secure them with a wire tie. Add the wheel once the motor is mounted and repeat for the other side. The battery holder is mounted on the bottom of the chassis, nestled between the motors. The wires from the battery holder should feed to the rear of the chassis. Assemble the rear wheel by adding the standoffs to the castor wheel as shown in the above left image. Then attach it to the chassis. The wires for the battery holder are shown feeding through the hole to the left of the motor wires. They will need to be fed through the right side (assembler error). Feed the screws up through the bottom of the chassis in the holes that were drilled. Use the plastic spacers to separate the board from the chassis (and clear the wires), then secure the board with the nuts. The board should be mounted such that the connections to the motor and battery wires face the rear of the chassis. The wires can now be trimmed and attached to the board. Carefully note that the black battery wire connects to the negative (-) green terminal and the red battery wire attaches to the positive (+) green terminal. The motor wires should connect to the black terminals, with the black wires on the outside (terminals labeled GP8 and GP 11) and the red wires on the inside (terminals labeled GP 9 and GP 10). Connecting the ultrasonic sensor Insert the ultrasonic sensor in the mount with the pins up (it will appear as if the sensor is mounted upside down, well it is). Then attach the mount to the front of the chassis with the short screws. The ultrasonic sensor measures distance using sonar, an ultrasonic (well above human hearing) pulse (~40KHz) is transmitted from the unit and distance-to-target is determined by measuring the time required for the echo return. The pins are labeled on the front of the module - Vcc (3.3 VDC), Trig, Echo, and Gnd. Connect the grove connector wires as follows: Wire Color Sensor Pin Red Vcc White Trig Yellow Echo Black Gnd Connect the other end of the grove wire harness to the grove 5 port. Use small wire ties to keep the wires secure. Connecting the bluetooth module The bluetooth module will nestle between the wire ties used to tidy up the wires. The bluetooth modules communicate at 9600 baud by default, although some older modules use 115200 baud. Communication is done through the built in UART on the board. The settings (baud rate, name, etc.) can be changed by sending AT commands to the module. Sending \"AT+HELP\" to the module will return a list of supported commands. The AT commands for getting/setting baud rate are: Send Receive Parameter AT+BAUD? OK+Get:[P1] P1: Baud Rate AT+BAUD[P1] OK+Set:[P1] 0: 9600; 1: 19200; 2: 38400 . 3: 57600; 4: 115200; 5: 4800 . 6: 2400; 7: 1200; 8: 230400 . Default: 0 (9600) The pins are usually labelled on the back of the module. Your module with either have six or four pins. Ignoring the outer most pins (assuming your module has six pins), the pins from left to right as you look at the back of the board are VCC (3.3 VDC), Gnd, Tx, & Rx. Connect the grove connector wires as follows: Wire Color Module Pin Red VCC Black GND Yellow TXD White RXD Connect the other end of the grove wire harness to the grove 3 port. N.B.: If you are using an Apple device to communicate with the bluetooth module, you must use the AT-09 module. Apple does not support the HC-05 bluetooth version. The instructions for using the line sensors are as follows Attach the sensors to the front of the chassis as shown above and the wires as below Wire Color Sensor Pin Red VCC Black GND White DO The left sensor should be connected to Grove 7 and the right sensor should be connected to Grove 1","title":"Build"},{"location":"makerpi/optumbot/build/#building-the-optumbot-remote-control-car-with-the-maker-pi-rp2040","text":"The bot brain is the Maker Pi RP2040. The Maker Pi board makes building a bot simple, since it is a one board solution built around the RP2040. The board comes with a dual channel DC motor driver, four servo motor ports, seven grove ports, a piezo, and two multi color leds. Maker Pi RP2040 Information The parts kit includes: Description Part Chassis kit Maker Pi RP2040 HC-05 or AT-09 Bluetooth module Ultrasonic sensor and mount Additional parts (not included in the kit): Nuts, bolts, and spacers Wire ties to secure wires Four AA batteries USB Micro B Cable Two optional IR Sensors for line following Additional software required: Software capable of connecting to and writing to the bluetooth module (I'm using LightBlue) Assemble the chassis Place the Maker PI RP2040 board on the rear of the chassis as shown and mark the small holes that are in each corner. Make sure the back of the board is closer to the back of the chassis, since the motors will end up close to the front board mounts. Once the holes are marked, drill the holes, using an 1/8 inch drill bit. Be careful, as your mounting holes may be close to existing mount holes in the chassis. Also note that the chassis is thin plastic, so it must be supported as you drill through it. After the holes are drilled, remove the paper from the chassis, motor mounts, and sensor mount. All parts should be clear plastic after the paper is romoved. Gather the wheel, motor, mounts, long screws, and nut as shown above. Slide the motor mounts through the chassis, then insert and secure the motor with the screws. Note that the wires will seperate from the motor if not handled with care. The wires should be on the side of the motor that faces out from the chassis. Once the motor is mounted, feed the wires through the chassis and optionally secure them with a wire tie. Add the wheel once the motor is mounted and repeat for the other side. The battery holder is mounted on the bottom of the chassis, nestled between the motors. The wires from the battery holder should feed to the rear of the chassis. Assemble the rear wheel by adding the standoffs to the castor wheel as shown in the above left image. Then attach it to the chassis. The wires for the battery holder are shown feeding through the hole to the left of the motor wires. They will need to be fed through the right side (assembler error). Feed the screws up through the bottom of the chassis in the holes that were drilled. Use the plastic spacers to separate the board from the chassis (and clear the wires), then secure the board with the nuts. The board should be mounted such that the connections to the motor and battery wires face the rear of the chassis. The wires can now be trimmed and attached to the board. Carefully note that the black battery wire connects to the negative (-) green terminal and the red battery wire attaches to the positive (+) green terminal. The motor wires should connect to the black terminals, with the black wires on the outside (terminals labeled GP8 and GP 11) and the red wires on the inside (terminals labeled GP 9 and GP 10). Connecting the ultrasonic sensor Insert the ultrasonic sensor in the mount with the pins up (it will appear as if the sensor is mounted upside down, well it is). Then attach the mount to the front of the chassis with the short screws. The ultrasonic sensor measures distance using sonar, an ultrasonic (well above human hearing) pulse (~40KHz) is transmitted from the unit and distance-to-target is determined by measuring the time required for the echo return. The pins are labeled on the front of the module - Vcc (3.3 VDC), Trig, Echo, and Gnd. Connect the grove connector wires as follows: Wire Color Sensor Pin Red Vcc White Trig Yellow Echo Black Gnd Connect the other end of the grove wire harness to the grove 5 port. Use small wire ties to keep the wires secure. Connecting the bluetooth module The bluetooth module will nestle between the wire ties used to tidy up the wires. The bluetooth modules communicate at 9600 baud by default, although some older modules use 115200 baud. Communication is done through the built in UART on the board. The settings (baud rate, name, etc.) can be changed by sending AT commands to the module. Sending \"AT+HELP\" to the module will return a list of supported commands. The AT commands for getting/setting baud rate are: Send Receive Parameter AT+BAUD? OK+Get:[P1] P1: Baud Rate AT+BAUD[P1] OK+Set:[P1] 0: 9600; 1: 19200; 2: 38400 . 3: 57600; 4: 115200; 5: 4800 . 6: 2400; 7: 1200; 8: 230400 . Default: 0 (9600) The pins are usually labelled on the back of the module. Your module with either have six or four pins. Ignoring the outer most pins (assuming your module has six pins), the pins from left to right as you look at the back of the board are VCC (3.3 VDC), Gnd, Tx, & Rx. Connect the grove connector wires as follows: Wire Color Module Pin Red VCC Black GND Yellow TXD White RXD Connect the other end of the grove wire harness to the grove 3 port. N.B.: If you are using an Apple device to communicate with the bluetooth module, you must use the AT-09 module. Apple does not support the HC-05 bluetooth version. The instructions for using the line sensors are as follows Attach the sensors to the front of the chassis as shown above and the wires as below Wire Color Sensor Pin Red VCC Black GND White DO The left sensor should be connected to Grove 7 and the right sensor should be connected to Grove 1","title":"Building the OptumBot remote control car with the Maker Pi RP2040"},{"location":"makerpi/optumbot/follow/","text":"Add an ultrasonic sensor and follow your hand Add an ultrasonic sensor to your chassis Once you added the sensor, build the blocks to initialize the sensor and display the distance reading in the console. As you run the program, move your hand in front of the chassis such that the distance changes. Note that your sensor may be connected to a different Grove connector. Now add the motor control Once you add the motor control, where do you think the sweet spot is such that it follows your hand as you move your hand away from and towards the sensor? We picked 100, but you may decide to move the threshold.","title":"Follow the Hand"},{"location":"makerpi/optumbot/follow/#add-an-ultrasonic-sensor-and-follow-your-hand","text":"","title":"Add an ultrasonic sensor and follow your hand"},{"location":"makerpi/optumbot/follow/#add-an-ultrasonic-sensor-to-your-chassis","text":"Once you added the sensor, build the blocks to initialize the sensor and display the distance reading in the console. As you run the program, move your hand in front of the chassis such that the distance changes. Note that your sensor may be connected to a different Grove connector.","title":"Add an ultrasonic sensor to your chassis"},{"location":"makerpi/optumbot/follow/#now-add-the-motor-control","text":"Once you add the motor control, where do you think the sweet spot is such that it follows your hand as you move your hand away from and towards the sensor? We picked 100, but you may decide to move the threshold.","title":"Now add the motor control"},{"location":"makerpi/optumbot/motors/","text":"Working with Motors in BIPES Assemble the Two Wheel Smart Car Chassis Before we work with motors, we'll want to assemble the smart car chassis. It is available from a number of vendors online. Cytron 2WD Smart Car Chassis YouTube Video of Assembly - note that he does not remove the backing paper on the Plexiglass and he mounts the battery on the top. We like ours on the bottom so we can mount the Maker Pi board on top. Check your motor wiring! Depending on how your motors are wired, you may need to change the motor initialization block from the displayed block below: The wiring can be tested by trying the motor movement blocks (forward, left, and right) If the car doesn't move in the direction(s) you expect, you will need to change the initialization block until the car moves correctly. Challenge Can you make the car travel in a square, ending up where it started?","title":"Motors"},{"location":"makerpi/optumbot/motors/#working-with-motors-in-bipes","text":"","title":"Working with Motors in BIPES"},{"location":"makerpi/optumbot/motors/#assemble-the-two-wheel-smart-car-chassis","text":"Before we work with motors, we'll want to assemble the smart car chassis. It is available from a number of vendors online. Cytron 2WD Smart Car Chassis YouTube Video of Assembly - note that he does not remove the backing paper on the Plexiglass and he mounts the battery on the top. We like ours on the bottom so we can mount the Maker Pi board on top.","title":"Assemble the Two Wheel Smart Car Chassis"},{"location":"makerpi/optumbot/motors/#check-your-motor-wiring","text":"Depending on how your motors are wired, you may need to change the motor initialization block from the displayed block below: The wiring can be tested by trying the motor movement blocks (forward, left, and right) If the car doesn't move in the direction(s) you expect, you will need to change the initialization block until the car moves correctly. Challenge Can you make the car travel in a square, ending up where it started?","title":"Check your motor wiring!"},{"location":"makerpi/optumbot/readUART/","text":"Reading from the UART Add a bluetooth module to your chassis Once you added the module, build the blocks to initialize the uart and display the data that you sent to the module. Note that the bluetooth module is connected to UART on Port 1 with a baudrate of 9600 baud. You'll need to use software on you phone, tablet or computer to send data to the bluetooth module. If you are using LightBlue, open the application and find the bluetooth module. Selecting the module will take you to the next screen with device information. Selecting the Characteristic section will allow you to write to the module. Change the data type from Hex to UTF-8. Then write a new value and send it. Now add the motor control Once again, add the motor control. Now make the car move forward and stop as you send commands to the module. Challenge Can you make the car travel in other directions?","title":"Reading from the UART"},{"location":"makerpi/optumbot/readUART/#reading-from-the-uart","text":"","title":"Reading from the UART"},{"location":"makerpi/optumbot/readUART/#add-a-bluetooth-module-to-your-chassis","text":"Once you added the module, build the blocks to initialize the uart and display the data that you sent to the module. Note that the bluetooth module is connected to UART on Port 1 with a baudrate of 9600 baud. You'll need to use software on you phone, tablet or computer to send data to the bluetooth module. If you are using LightBlue, open the application and find the bluetooth module. Selecting the module will take you to the next screen with device information. Selecting the Characteristic section will allow you to write to the module. Change the data type from Hex to UTF-8. Then write a new value and send it.","title":"Add a bluetooth module to your chassis"},{"location":"makerpi/optumbot/readUART/#now-add-the-motor-control","text":"Once again, add the motor control. Now make the car move forward and stop as you send commands to the module. Challenge Can you make the car travel in other directions?","title":"Now add the motor control"},{"location":"pico/01-intro/","text":"Introduction to using a Raspberry Pico with BIPES These lessons assume that you have at least skimmed the Getting Started sections and have selected the Raspberry Pi Pico in BIPES to write your code. The lessons will introduce you to using BIPES with the $4 Raspberry Pi Pico. The first example just uses the Raspberry Pi Pico and its internal LED. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction"},{"location":"pico/01-intro/#introduction-to-using-a-raspberry-pico-with-bipes","text":"These lessons assume that you have at least skimmed the Getting Started sections and have selected the Raspberry Pi Pico in BIPES to write your code. The lessons will introduce you to using BIPES with the $4 Raspberry Pi Pico. The first example just uses the Raspberry Pi Pico and its internal LED. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction to using a Raspberry Pico with BIPES"},{"location":"pico/actuators/servo/","text":"Controlling a Servo Motor with BIPES Types of Servos Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos. Servo Connections Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow) A set of blocks used to rotate 180 degrees (-90 through 90) references SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"RC Servo"},{"location":"pico/actuators/servo/#controlling-a-servo-motor-with-bipes","text":"","title":"Controlling a Servo Motor with BIPES"},{"location":"pico/actuators/servo/#types-of-servos","text":"Although there are may types of servos you can purchase, in our labs there are two main types of servos that we use: SG90 Micro Servo, 9 grams, 180 degree, plastic gears - $4 MG90S Micro Servo, 9 grams, 180 degree, metal gears - $5 There are other variations that have 360 degree or continuous rotation servos.","title":"Types of Servos"},{"location":"pico/actuators/servo/#servo-connections","text":"Almost all servos have a three pin connector that are spaced 1/10th of an inch apart so they will work with our breadboards. Ground (black or brown wire) 5 volt power (always red) Data (orange or yellow)","title":"Servo Connections"},{"location":"pico/actuators/servo/#a-set-of-blocks-used-to-rotate-180-degrees-90-through-90","text":"","title":"A set of blocks used to rotate 180 degrees (-90 through 90)"},{"location":"pico/actuators/servo/#references","text":"SparkFun Servos Page SparkFun Category for Servos eBay Servo Plastic Servo eBay Servo Metal Gear Servo","title":"references"},{"location":"pico/basics/blink/","text":"Blink in BIPES Overview In this lab, we will use BIPES to make the green on-board LED on the Raspberry Pi Pico blink on and off every half second. The only things you need to run this program are BIPES a USB cable a $4 Raspberry Pi Pico microcontroller Blinking the Builtin LED The pico has a single built in green LED wired to logical pin 25. We call this GPIO 25. GPIO means General Purpose Input and Output pin. Here is a sample program that you can use. Don't worry about understanding each block yet. We will cover the various parts in later sections. Take a look at the left navigation. Each section in the navigation contains different items that you will use to run your program. We used blocks from Loops , Logic , Machine:In_Out Pins , and Timing . The green block comes from the Loops navigation section. Anything inside the green block repeats while true . true comes from the Logic navigation section. Thus the program will run forever, or until we stop it. The first blook inside the loop comes from the Machine:In/Out Pins navigation section. We are setting the onboard LED to true (on). The next block is a delay for 1/2 second. The delay comes from the Timing navigation section. We repeat those two blocks, this time setting the onboard LED to false (off). Changing the Blink Speed Next, lets create a variable from the Variable navigation section for the delay that the LED is on and off. The number in the delay block comes from the Math navigation section. This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye? Blinking external LEDs Although the builtin LED is convenient, you can use the code to blink any number of external LEDs that are connected through a 330 ohm resister in series to the LED. Hints: We will assume that LEDs are connected to pins GPIO16 and GPIO17 and are connected via a 330 ohm resistor to ground. The longer lead on the LED is the Anode (+) lead, connect it to the GPIO pins on the pico Modify the first program Note which GPIO pins are connected to each LED Here are the blocks that will blink the LEDs that are connected to GPIO16 & GPIO17 time 10 times, then turn off the remaining lit LED.","title":"Blink"},{"location":"pico/basics/blink/#blink-in-bipes","text":"","title":"Blink in BIPES"},{"location":"pico/basics/blink/#overview","text":"In this lab, we will use BIPES to make the green on-board LED on the Raspberry Pi Pico blink on and off every half second. The only things you need to run this program are BIPES a USB cable a $4 Raspberry Pi Pico microcontroller","title":"Overview"},{"location":"pico/basics/blink/#blinking-the-builtin-led","text":"The pico has a single built in green LED wired to logical pin 25. We call this GPIO 25. GPIO means General Purpose Input and Output pin. Here is a sample program that you can use. Don't worry about understanding each block yet. We will cover the various parts in later sections. Take a look at the left navigation. Each section in the navigation contains different items that you will use to run your program. We used blocks from Loops , Logic , Machine:In_Out Pins , and Timing . The green block comes from the Loops navigation section. Anything inside the green block repeats while true . true comes from the Logic navigation section. Thus the program will run forever, or until we stop it. The first blook inside the loop comes from the Machine:In/Out Pins navigation section. We are setting the onboard LED to true (on). The next block is a delay for 1/2 second. The delay comes from the Timing navigation section. We repeat those two blocks, this time setting the onboard LED to false (off).","title":"Blinking the Builtin LED"},{"location":"pico/basics/blink/#changing-the-blink-speed","text":"Next, lets create a variable from the Variable navigation section for the delay that the LED is on and off. The number in the delay block comes from the Math navigation section. This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye?","title":"Changing the Blink Speed"},{"location":"pico/basics/blink/#blinking-external-leds","text":"Although the builtin LED is convenient, you can use the code to blink any number of external LEDs that are connected through a 330 ohm resister in series to the LED. Hints: We will assume that LEDs are connected to pins GPIO16 and GPIO17 and are connected via a 330 ohm resistor to ground. The longer lead on the LED is the Anode (+) lead, connect it to the GPIO pins on the pico Modify the first program Note which GPIO pins are connected to each LED Here are the blocks that will blink the LEDs that are connected to GPIO16 & GPIO17 time 10 times, then turn off the remaining lit LED.","title":"Blinking external LEDs"},{"location":"pico/basics/button/","text":"Button In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard . Momentary Switch Buttons We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code. Sample Button Polling Code Here is our fist example that uses a simple \"watching\" loop to check if the button value has changed 10 times per second. In this case, the built-in LED is connected to pin 25. Interrupt Handler Version Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handle external events such as a button press. You can see the count of button presses in the console. Interrupt Handler with a Debounce Feature One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here are the blocks of this \"Debounce\" code: References Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"Button"},{"location":"pico/basics/button/#button","text":"In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard .","title":"Button"},{"location":"pico/basics/button/#momentary-switch-buttons","text":"We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code.","title":"Momentary Switch Buttons"},{"location":"pico/basics/button/#sample-button-polling-code","text":"Here is our fist example that uses a simple \"watching\" loop to check if the button value has changed 10 times per second. In this case, the built-in LED is connected to pin 25.","title":"Sample Button Polling Code"},{"location":"pico/basics/button/#interrupt-handler-version","text":"Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handle external events such as a button press. You can see the count of button presses in the console.","title":"Interrupt Handler Version"},{"location":"pico/basics/button/#interrupt-handler-with-a-debounce-feature","text":"One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here are the blocks of this \"Debounce\" code:","title":"Interrupt Handler with a Debounce Feature"},{"location":"pico/basics/button/#references","text":"Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"References"},{"location":"pico/basics/fadeInAndOut/","text":"Fade an LED in and Out In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want. Welcome to Pulse Width Modulation Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? The rate of change of the pulse is called the frequency. How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. A GPIO pin is declared a PWM output when you use the PWM block found in the Machine: In/Out Pins navigation section. The block initializes a pin to be a PWM pin. Frequency and duty cycle can then be set individually. Conversly, the RPI PWM block lets you set both the frequency and duty cycle when the pin is initalized. Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again. Suggested Exercises Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM? References Pulse With Modulation Wikipedia Article on Pulse With Modulation","title":"Fade in and out"},{"location":"pico/basics/fadeInAndOut/#fade-an-led-in-and-out","text":"In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want.","title":"Fade an LED in and Out"},{"location":"pico/basics/fadeInAndOut/#welcome-to-pulse-width-modulation","text":"Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? The rate of change of the pulse is called the frequency. How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. A GPIO pin is declared a PWM output when you use the PWM block found in the Machine: In/Out Pins navigation section. The block initializes a pin to be a PWM pin. Frequency and duty cycle can then be set individually. Conversly, the RPI PWM block lets you set both the frequency and duty cycle when the pin is initalized. Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again.","title":"Welcome to Pulse Width Modulation"},{"location":"pico/basics/fadeInAndOut/#suggested-exercises","text":"Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM?","title":"Suggested Exercises"},{"location":"pico/basics/fadeInAndOut/#references","text":"","title":"References"},{"location":"pico/basics/fadeInAndOut/#pulse-with-modulation","text":"Wikipedia Article on Pulse With Modulation","title":"Pulse With Modulation"},{"location":"pico/basics/potentiometer/","text":"MicroPython Potentiometer Lab In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED. About Analog to Digital Converters Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. Circuit Diagram Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico. Sample set of blocks To Print Potentiometer Values 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Changing Blink Speed with a Potentiometer The following video shows this script in action. Changing the Brightness of the Built in LED We can change the brightness of the builtin LED by using the POT value to change the PWM duty cycle. Here is a sample set of blocks that does this:","title":"Potentiometer"},{"location":"pico/basics/potentiometer/#micropython-potentiometer-lab","text":"In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED.","title":"MicroPython Potentiometer Lab"},{"location":"pico/basics/potentiometer/#about-analog-to-digital-converters","text":"Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin.","title":"About Analog to Digital Converters"},{"location":"pico/basics/potentiometer/#circuit-diagram","text":"Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico.","title":"Circuit Diagram"},{"location":"pico/basics/potentiometer/#sample-set-of-blocks-to-print-potentiometer-values","text":"1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Sample set of blocks To Print Potentiometer Values"},{"location":"pico/basics/potentiometer/#changing-blink-speed-with-a-potentiometer","text":"The following video shows this script in action.","title":"Changing Blink Speed with a Potentiometer"},{"location":"pico/basics/potentiometer/#changing-the-brightness-of-the-built-in-led","text":"We can change the brightness of the builtin LED by using the POT value to change the PWM duty cycle. Here is a sample set of blocks that does this:","title":"Changing the Brightness of the Built in LED"},{"location":"pico/displays/neopixel/","text":"NeoPixels NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of March of 2022 there is now built-in support for NeoPixels in the MicroPython 1.18 runtime for the Raspberry Pi RP2040 microcontroller. Although you can still use custom libraries, this tutorial assumes you are using version 1.18 or later. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266 Different Types of NeoPixels There are many different types of NeoPixels. They come in many forms such as strips, rings and matrices. The most common type of NeoPixels are strips. The strips come in a variety of densities and waterproofing. The most common and easiest to use are the 60 pixels-per-meter type. Circuit connections LED Strip Pico Name Pico Pin Description GND GND 38 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 0 Row 1 on the left side Note that you can also power most of the LED strips using the 3.3 volts available on Grove connectors. The only difference is the brightness might not be quite as high, but for most applications this will not be a problem. Setup Parameters Our block will have two parts: Initialization of the NeoPixel object using the static block parameters. This is also done just once. Sending the drawing commands to the device through the data port. This is usually done within a main loop. Sample Programs Now we are ready to write our first small test program! Move Red Pixel Across Strip Fade in and Out Make the first pixel fade the red color in and out. We do this by slowly turning up the color level of the red on the NeoPixel. We start a 0 and go up to 255. Then we go back from 255 back down to zero. We delay about 5 milliseconds between each of the 255 brightness levels. Heartbeat Lab What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an electro cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. The following blocks emulate this heart beat pattern: Move Red, Green and Blue The following program will just take the blocks in the loop above and move it into a function, then call the function with red, blue, and green. Rainbow Cycle The program cycles each pixel through all the colors in a rainbow. It uses two functions: wheel(pos) this function takes a position parameter from 0 to 255 and returns a triple of numbers for the red, green and blue values as the position moves around the color wheel. This is a handy program anytime you want to cycle through all the colors of the rainbow! rainbow_cycle will cycle each of the pixels in a strip through the color wheel. It gives the appearance that colors are moving across the strip. The wait is the delay time between updating the colors. A typical value for wait is .05 seconds or 50 milliseconds. References MicroPython RP2 Reference for NeoPixel Driver Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel (used before version 1.18 of the MicroPython RP2 Runtime) - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"NeoPixel"},{"location":"pico/displays/neopixel/#neopixels","text":"NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of March of 2022 there is now built-in support for NeoPixels in the MicroPython 1.18 runtime for the Raspberry Pi RP2040 microcontroller. Although you can still use custom libraries, this tutorial assumes you are using version 1.18 or later. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266","title":"NeoPixels"},{"location":"pico/displays/neopixel/#different-types-of-neopixels","text":"There are many different types of NeoPixels. They come in many forms such as strips, rings and matrices. The most common type of NeoPixels are strips. The strips come in a variety of densities and waterproofing. The most common and easiest to use are the 60 pixels-per-meter type.","title":"Different Types of NeoPixels"},{"location":"pico/displays/neopixel/#circuit-connections","text":"LED Strip Pico Name Pico Pin Description GND GND 38 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 0 Row 1 on the left side Note that you can also power most of the LED strips using the 3.3 volts available on Grove connectors. The only difference is the brightness might not be quite as high, but for most applications this will not be a problem.","title":"Circuit connections"},{"location":"pico/displays/neopixel/#setup-parameters","text":"Our block will have two parts: Initialization of the NeoPixel object using the static block parameters. This is also done just once. Sending the drawing commands to the device through the data port. This is usually done within a main loop.","title":"Setup Parameters"},{"location":"pico/displays/neopixel/#sample-programs","text":"Now we are ready to write our first small test program!","title":"Sample Programs"},{"location":"pico/displays/neopixel/#move-red-pixel-across-strip","text":"","title":"Move Red Pixel Across Strip"},{"location":"pico/displays/neopixel/#fade-in-and-out","text":"Make the first pixel fade the red color in and out. We do this by slowly turning up the color level of the red on the NeoPixel. We start a 0 and go up to 255. Then we go back from 255 back down to zero. We delay about 5 milliseconds between each of the 255 brightness levels.","title":"Fade in and Out"},{"location":"pico/displays/neopixel/#heartbeat-lab","text":"What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an electro cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. The following blocks emulate this heart beat pattern:","title":"Heartbeat Lab"},{"location":"pico/displays/neopixel/#move-red-green-and-blue","text":"The following program will just take the blocks in the loop above and move it into a function, then call the function with red, blue, and green.","title":"Move Red, Green and Blue"},{"location":"pico/displays/neopixel/#rainbow-cycle","text":"The program cycles each pixel through all the colors in a rainbow. It uses two functions: wheel(pos) this function takes a position parameter from 0 to 255 and returns a triple of numbers for the red, green and blue values as the position moves around the color wheel. This is a handy program anytime you want to cycle through all the colors of the rainbow! rainbow_cycle will cycle each of the pixels in a strip through the color wheel. It gives the appearance that colors are moving across the strip. The wait is the delay time between updating the colors. A typical value for wait is .05 seconds or 50 milliseconds.","title":"Rainbow Cycle"},{"location":"pico/displays/neopixel/#references","text":"MicroPython RP2 Reference for NeoPixel Driver Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel (used before version 1.18 of the MicroPython RP2 Runtime) - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"References"},{"location":"pico/displays/ssd1306/","text":"OLED SSD1306 Examples Using the SSD1306 with I2C Interfaces Hello World After this program runs you should see the text on your OLED display. Counter Example In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50. Animated Box This draws a title and four lines around a drawing area. It then draws boxes that move to the right. References MicroPython Tutorial on the SSD1306 M Fitzp OLED Display i2c Article Adafruit Stats DIY More OLED Product Description Using I2C Defaults","title":"SSD1306 OLED"},{"location":"pico/displays/ssd1306/#oled-ssd1306-examples","text":"","title":"OLED SSD1306 Examples"},{"location":"pico/displays/ssd1306/#using-the-ssd1306-with-i2c-interfaces","text":"","title":"Using the SSD1306 with I2C Interfaces"},{"location":"pico/displays/ssd1306/#hello-world","text":"After this program runs you should see the text on your OLED display.","title":"Hello World"},{"location":"pico/displays/ssd1306/#counter-example","text":"In this example we will updated the display 50 times with a 1/10th of a second pause between each refresh. A counter will cycle from 1 to 50.","title":"Counter Example"},{"location":"pico/displays/ssd1306/#animated-box","text":"This draws a title and four lines around a drawing area. It then draws boxes that move to the right.","title":"Animated Box"},{"location":"pico/displays/ssd1306/#references","text":"MicroPython Tutorial on the SSD1306 M Fitzp OLED Display i2c Article Adafruit Stats DIY More OLED Product Description Using I2C Defaults","title":"References"},{"location":"pico/music/tunes/","text":"Introduction to Sound and Music in MicroPython How Microcontrollers Generate Sound Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code: Duty Cycle The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. Fortunately, BIPES take care of this for us. Playing sounds is as simple as loading the rtttl library. If you are looking to play a song, load the songs as well, then play your tunes. See the sample block below. Connecting a Sound Device There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board References https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"Music"},{"location":"pico/music/tunes/#introduction-to-sound-and-music-in-micropython","text":"","title":"Introduction to Sound and Music in MicroPython"},{"location":"pico/music/tunes/#how-microcontrollers-generate-sound","text":"Microcontrollers are really great at generating digital outputs on their GPIO pins. These digital signals that quickly switch between zero and a positive voltage like 3.3 or 5 volts. However, they are not designed to create \"analog\" output of a continuous varying voltage. However, we can use a technique called \"Pulse Width Modulation\" to simulate the various frequencies of sound using digital only outputs. Pulse Width Modulation is the process of changing not the height of a electrical signal, but the width between the pulses of digital signals. By changing the distance of the spaces between the digital signals we can generate a signal that will sound like it has a higher or lower frequency or pitch. MicroPython provides a powerful library of tools for you to easily generate pulses of different shapes. This is called the PWM library. Will will use this in our sound and music programs. Here is a sample of how this is called in our code:","title":"How Microcontrollers Generate Sound"},{"location":"pico/music/tunes/#duty-cycle","text":"The Duty Cycle is what percent of time a pulse is high. For working with sound, we want to generate smooth sound waves that are on 1/2 of the time and off 1/2 of the time. So our duty cycles will be set to be 50%. Fortunately, BIPES take care of this for us. Playing sounds is as simple as loading the rtttl library. If you are looking to play a song, load the songs as well, then play your tunes. See the sample block below.","title":"Duty Cycle"},{"location":"pico/music/tunes/#connecting-a-sound-device","text":"There are several different ways that you can connect a sound device to you MicroController. Here are three options: Buzzers - These are small inexpensive devices that can mount directly on your breadboard. Piezoelectric Speaker - Wikipedia Page on Piezoelectric Speaker Speaker - A magnetic speaker with our without an amplifier is another way to hear sound. You can also purchase a small amplifier to increase the volume. Amplifier - For about $1.20 you can purchase a small amplifier for your speaker. eBay LM386 DC 5V-12V Mini Micro Audio Amplifier Module Board","title":"Connecting a Sound Device"},{"location":"pico/music/tunes/#references","text":"https://electronics.stackexchange.com/questions/288930/what-is-the-difference-between-a-buzzer-and-a-speaker-and-are-there-any-other-ba","title":"References"},{"location":"pico/sensors/dht11Sensor/","text":"Sensing Temperature and Humidity with the DHT11 Sensor Sample Blocks References Peppe80's Example Axel \u00d6rn Sigur\u00f0sson's DHT11 Driver","title":"Temperature and humidity sensor (DHT11)"},{"location":"pico/sensors/dht11Sensor/#sensing-temperature-and-humidity-with-the-dht11-sensor","text":"","title":"Sensing Temperature and Humidity with the DHT11 Sensor"},{"location":"pico/sensors/dht11Sensor/#sample-blocks","text":"","title":"Sample Blocks"},{"location":"pico/sensors/dht11Sensor/#references","text":"Peppe80's Example Axel \u00d6rn Sigur\u00f0sson's DHT11 Driver","title":"References"},{"location":"pico/sensors/mpu6050Sensor/","text":"MPU-6050 Accelerometer Gyroscope Temperature MPU6050 is a Micro Electro-mechanical system (MEMS), it consists of three-axis accelerometer and three-axis gyroscope. It helps us to measure velocity, orientation, acceleration, displacement and other motion like features. (Gyro + Accelerometer) MEMS MotionTracking\u2122 Device How the MPU6050 works Pinouts VIN: Voltage Supply Pin GND: 0V Power Supply SCL: I2C Clock Input SDA: I2C Data Input XDO: I2C Data Output XCL: I2C Clock Output ADO: Determines the I2C address of the module INT: Interrupt Output You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed. MPU6050 Drivers and sample blocks Make sure to load two libraries, the imu library and the vector3d library","title":"Inertial measurement sensor (MPU6050)"},{"location":"pico/sensors/mpu6050Sensor/#mpu-6050-accelerometer-gyroscope-temperature","text":"MPU6050 is a Micro Electro-mechanical system (MEMS), it consists of three-axis accelerometer and three-axis gyroscope. It helps us to measure velocity, orientation, acceleration, displacement and other motion like features. (Gyro + Accelerometer) MEMS MotionTracking\u2122 Device How the MPU6050 works","title":"MPU-6050 Accelerometer Gyroscope Temperature"},{"location":"pico/sensors/mpu6050Sensor/#pinouts","text":"VIN: Voltage Supply Pin GND: 0V Power Supply SCL: I2C Clock Input SDA: I2C Data Input XDO: I2C Data Output XCL: I2C Clock Output ADO: Determines the I2C address of the module INT: Interrupt Output You only need to hook the 3.3 to VIN, the GND to GND and the SCL and SDA. The other connections are not needed.","title":"Pinouts"},{"location":"pico/sensors/mpu6050Sensor/#mpu6050-drivers-and-sample-blocks","text":"Make sure to load two libraries, the imu library and the vector3d library","title":"MPU6050 Drivers and sample blocks"},{"location":"pico/sensors/photoSensor/","text":"Light Sensor with Raspberry Pi Pico with BIPES A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit. Circuit We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy. Sample Blocks Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. When you run the program a series of print values is displayed in the console every 1/5th of a second. Look to see how the numbers change as you cover and uncover detector from a light source. Experiments What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like? References Wikipedia Page on Photoresistor","title":"Photo sensor"},{"location":"pico/sensors/photoSensor/#light-sensor-with-raspberry-pi-pico-with-bipes","text":"A photoresistor is a sensor that decreases resistance when light is shined on its surface. With no light a photoresistor has high resistance in the range of megaohms. As light shines on the surface the resistance drops to kiloohms. We can use this effect as a light sensor. To convert the variable resistance of a photoresistor to something we can measure with our microcontroller we will need to build a small circuit that includes a 10K ohm resistor. We then measure the voltage between the photoresistor and the 10K resistor as light falls on the sensor. The top and bottom of the circuit are tied to ground and a power rail. This will move the voltage of the midpoint of the circuit.","title":"Light Sensor with Raspberry Pi Pico with BIPES"},{"location":"pico/sensors/photoSensor/#circuit","text":"We want to make sure that we use the stable analog ground (AGND) and analog to reference voltage at either end of the circuit to protect the circuit from all the noise of the power in our processor. Using other power and ground pins will work, but power fluctuations will make the result noisy.","title":"Circuit"},{"location":"pico/sensors/photoSensor/#sample-blocks","text":"Our program will first use the Analog to Digital Circuit (ADC0) as an input. On the Pico this is on pin 26. When you run the program a series of print values is displayed in the console every 1/5th of a second. Look to see how the numbers change as you cover and uncover detector from a light source.","title":"Sample Blocks"},{"location":"pico/sensors/photoSensor/#experiments","text":"What types of devices could use a light detector? How does a night-light work? How could you add an LED to the circuit so that the LED would turn on if the light level got too low? Could you automatically adjust the brightness of LEDs on a costume to get brighter in a sunny room and dim if you enter a dark room? What would that code look like?","title":"Experiments"},{"location":"pico/sensors/photoSensor/#references","text":"Wikipedia Page on Photoresistor","title":"References"},{"location":"pico/sensors/pingSensor/","text":"Ultrasound Ping Sensor The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it. Wiring Diagram Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner. Sample Blocks The Ultrasound Ping sensor is found in the left navigation Sensors: Ultrasound . Make sure to load the library for the sensor","title":"Ping sensor"},{"location":"pico/sensors/pingSensor/#ultrasound-ping-sensor","text":"The HC-SR04 is a low cost ($4) sensor that measures the distance to an object in front of it.","title":"Ultrasound Ping Sensor"},{"location":"pico/sensors/pingSensor/#wiring-diagram","text":"Connect GND to any GND pin on the Pico Connnect VCC to VBUS or 5 Volt power Connect Trigger to pin 15. With USB on the top, this pin is the bottom left corner. Connect Echo to pin 14. One up from bottom left corner.","title":"Wiring Diagram"},{"location":"pico/sensors/pingSensor/#sample-blocks","text":"The Ultrasound Ping sensor is found in the left navigation Sensors: Ultrasound . Make sure to load the library for the sensor","title":"Sample Blocks"}]}