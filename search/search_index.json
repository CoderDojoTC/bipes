{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BIPES Block Programming with MicroPython BIPES Block Programming with MicroPython Block-based Integrated Platform for Embedded Systems (BIPES), an open source project developed in partnership with a range of universities to develop a drag-and-drop visual programming environment for the embedded world, has support for the Raspberry Pi Pico and its RP2040 microcontroller. BIPES has been extended to add support for the Raspberry Pi Pico W as well as the Maker Pi RP2040 based Optum Bot. Read more about the history of BIPES here","title":"BIPES Home"},{"location":"#bipes-block-programming-with-micropython","text":"BIPES Block Programming with MicroPython Block-based Integrated Platform for Embedded Systems (BIPES), an open source project developed in partnership with a range of universities to develop a drag-and-drop visual programming environment for the embedded world, has support for the Raspberry Pi Pico and its RP2040 microcontroller. BIPES has been extended to add support for the Raspberry Pi Pico W as well as the Maker Pi RP2040 based Optum Bot. Read more about the history of BIPES here","title":"BIPES Block Programming with MicroPython"},{"location":"contacts/","text":"BIPES Contacts Jim Tannenbaum (aka \"JET\") Dan McCreary","title":"Contacts"},{"location":"contacts/#bipes-contacts","text":"Jim Tannenbaum (aka \"JET\") Dan McCreary","title":"BIPES Contacts"},{"location":"contributing/","text":"Contributing We welcome anyone that has sample lesson plans they would like to contribute. You can use the following ways to contribute: Submit a pull request Add an issue to our issue tracker Send one of us your sample lesson plans or code via e-mail. You can see our contacts on the Contacts page. Authoring Guidelines This site is built using Markdown, GitHub Pages and mkdocs using the mkdocs-material theme. See our authoring guidelines for further details: Content Authoring Guide","title":"Contributing"},{"location":"contributing/#contributing","text":"We welcome anyone that has sample lesson plans they would like to contribute. You can use the following ways to contribute: Submit a pull request Add an issue to our issue tracker Send one of us your sample lesson plans or code via e-mail. You can see our contacts on the Contacts page.","title":"Contributing"},{"location":"contributing/#authoring-guidelines","text":"This site is built using Markdown, GitHub Pages and mkdocs using the mkdocs-material theme. See our authoring guidelines for further details: Content Authoring Guide","title":"Authoring Guidelines"},{"location":"glossary/","text":"BIPES Glossary Here is a glossary of terms we use in these courses. BIPES Block-based Integrated Platform for Embedded Systems See https://bipes.net.br/wp/ Raspberry Pi Pico A low-cost $4 microcontroller that you can program with BIPES.","title":"Glossary"},{"location":"glossary/#bipes-glossary","text":"Here is a glossary of terms we use in these courses.","title":"BIPES Glossary"},{"location":"glossary/#bipes","text":"Block-based Integrated Platform for Embedded Systems See https://bipes.net.br/wp/","title":"BIPES"},{"location":"glossary/#raspberry-pi-pico","text":"A low-cost $4 microcontroller that you can program with BIPES.","title":"Raspberry Pi Pico"},{"location":"references/","text":"BIPES References https://bipes.net.br/wp/","title":"References"},{"location":"references/#bipes-references","text":"https://bipes.net.br/wp/","title":"BIPES References"},{"location":"intro/01-intro/","text":"An introduction to BIPES What is BIPES BIPES (Block based Integrated Platform for Embedded Systems) allows text and block based programming for several types of embedded systems and Internet of Things modules using MicroPython. You can connect, program, debug and monitor several types of boards using a serial USB connection. Why BIPES is Fun BIPES hides the complexity of MicroPython by allowing users to program microcontrollers via an easy to use graphical interface. BIPES has several built in libraries that make adding accessories to your microcontroller simple. The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts. About this site This site provides a rich collection of resources to teach computational thinking to students from 10 to 16 years old using fun programs that control the physical world around us. The sub-field of computer science that reads sensors and controls lights and motors is called Physical Computing. You can read about physical computing on our MicroPython site. Want to learn more? This site will concentrate on using BIPES to program the Raspberry Pi Pico and the Cytron Maker Pi 2040 boards. The lessons are based, in part, on the MicroPython lessons covered in our MicroPython for Kids site. A discussion of how a breadboard works , different types of microcontrollers , and the Raspberry Pi Pico are all covered on that site.","title":"About BIPES"},{"location":"intro/01-intro/#an-introduction-to-bipes","text":"","title":"An introduction to BIPES"},{"location":"intro/01-intro/#what-is-bipes","text":"BIPES (Block based Integrated Platform for Embedded Systems) allows text and block based programming for several types of embedded systems and Internet of Things modules using MicroPython. You can connect, program, debug and monitor several types of boards using a serial USB connection.","title":"What is BIPES"},{"location":"intro/01-intro/#why-bipes-is-fun","text":"BIPES hides the complexity of MicroPython by allowing users to program microcontrollers via an easy to use graphical interface. BIPES has several built in libraries that make adding accessories to your microcontroller simple. The underlying code can be viewed in the console, giving the interested user the ability to learn as they build on coding concepts.","title":"Why BIPES is Fun"},{"location":"intro/01-intro/#about-this-site","text":"This site provides a rich collection of resources to teach computational thinking to students from 10 to 16 years old using fun programs that control the physical world around us. The sub-field of computer science that reads sensors and controls lights and motors is called Physical Computing. You can read about physical computing on our MicroPython site.","title":"About this site"},{"location":"intro/01-intro/#want-to-learn-more","text":"This site will concentrate on using BIPES to program the Raspberry Pi Pico and the Cytron Maker Pi 2040 boards. The lessons are based, in part, on the MicroPython lessons covered in our MicroPython for Kids site. A discussion of how a breadboard works , different types of microcontrollers , and the Raspberry Pi Pico are all covered on that site.","title":"Want to learn more?"},{"location":"intro/02-getting-started/","text":"Getting Started Before getting started with BIPES, follow the directions below to setup your microcontroller. Setup However, before getting started with BIPES, your microcontroller board must be setup. Regardless of which board you are using, you should start by doing the following steps: Download the flash_nuke.utf file to your computer. Download the latest MicroPython utf file to your computer. Hold down the BOOTSEL button on the Pico or the BOOT button on the Maker Pi then connect your microcontroller board to your computer with a micro usb cable and it will appear as a drive onto which you can drag the flash_nuke.uf2 file If you don't see the Maker Pi board, make sure the on/off switch is in the on position before connecting to your computer. Once the drive reappears, copy the MicroPython utf file to your device. If you are having trouble, take a look at the Drag-and-Drop MicroPython page Working with BIPES Working with BIPES is easy, since there is nothing to load on your computer. BIPES can be found online . Once the Welcome screen loads in your browser, you can do the following: Close the Welcome screen Select your board: The Raspberry Pi Pico The Maker Pi RP2040 Connect to your board Serial connection Select the comm port for your board The left navigation pane contains all of the blocks you will need to run the examples for the Raspberry Pi Pico and the Maker Pi RP2040 microcontrollers. Congratulations! You are ready to start using BIPES.","title":"Getting Started"},{"location":"intro/02-getting-started/#getting-started","text":"Before getting started with BIPES, follow the directions below to setup your microcontroller.","title":"Getting Started"},{"location":"intro/02-getting-started/#setup","text":"However, before getting started with BIPES, your microcontroller board must be setup. Regardless of which board you are using, you should start by doing the following steps: Download the flash_nuke.utf file to your computer. Download the latest MicroPython utf file to your computer. Hold down the BOOTSEL button on the Pico or the BOOT button on the Maker Pi then connect your microcontroller board to your computer with a micro usb cable and it will appear as a drive onto which you can drag the flash_nuke.uf2 file If you don't see the Maker Pi board, make sure the on/off switch is in the on position before connecting to your computer. Once the drive reappears, copy the MicroPython utf file to your device. If you are having trouble, take a look at the Drag-and-Drop MicroPython page","title":"Setup"},{"location":"intro/02-getting-started/#working-with-bipes","text":"Working with BIPES is easy, since there is nothing to load on your computer. BIPES can be found online . Once the Welcome screen loads in your browser, you can do the following: Close the Welcome screen Select your board: The Raspberry Pi Pico The Maker Pi RP2040 Connect to your board Serial connection Select the comm port for your board The left navigation pane contains all of the blocks you will need to run the examples for the Raspberry Pi Pico and the Maker Pi RP2040 microcontrollers. Congratulations! You are ready to start using BIPES.","title":"Working with BIPES"},{"location":"pico/basics/01-intro/","text":"Introduction to using a Raspberry Pico with BIPES This lesson assumes that you have at least skimmed the Getting Started sections and have selected the Raspberry Pi Pico in BIPES to write your code. The lesson will introduce you to the basic concepts of using BIPES using the $4 Raspberry Pi Pico. The first example just use the Raspberry Pi Pico and and its internal LED. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction"},{"location":"pico/basics/01-intro/#introduction-to-using-a-raspberry-pico-with-bipes","text":"This lesson assumes that you have at least skimmed the Getting Started sections and have selected the Raspberry Pi Pico in BIPES to write your code. The lesson will introduce you to the basic concepts of using BIPES using the $4 Raspberry Pi Pico. The first example just use the Raspberry Pi Pico and and its internal LED. All the subsequent examples will require you to place components on a solderless breadboard.","title":"Introduction to using a Raspberry Pico with BIPES"},{"location":"pico/basics/blink/","text":"Blink in BIPES Overview In this lab, we will use BIPES to make the green on-board LED on the Raspberry Pi Pico blink on and off every half second. The only things you need to run this program are BIPES a USB cable a $4 Raspberry Pi Pico microcontroller Blinking the Builtin LED The pico has a single built in green LED wired to logical pin 25. We call this GPIO 25. GPIO means General Purpose Input and Output pin. Here is a sample program that you can use. Don't worry about understanding each block yet. We will cover the various parts in later sections. Take a look at the left navigation. Each section in the navigation contains different items that you will use to run your program. We used blocks from Loops , Logic , Machine:In_Out Pins , and Timing . The green block comes from the Loops navigation section. Anything inside the green block repeats while true . true comes from the Logic navigation section. Thus the program will run forever, or until we stop it. The first blook inside the loop comes from the Machine:In/Out Pins navigation section. We are setting the onboard LED to true (on). The next block is a delay for 1/2 second. The delay comes from the Timing navigation section. We repeat those two blocks, this time setting the onboard LED to false (off). Changing the Blink Speed Next, lets create a variable from the Variable navigation section for the delay that the LED is on and off. The number in the delay block comes from the Math navigation section. This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye? Blinking external LEDs Although the builtin LED is convenient, you can use the code to blink any number of external LEDs that are connected through a 330 ohm resister in series to the LED. Hints: We will assume that LEDs are connected to pins GPIO16 and GPIO17 and are connected via a 330 ohm resistor to ground. The longer lead on the LED is the Anode (+) lead, connect it to the GPIO pins on the pico Modify the first program Note which GPIO pins are connected to each LED Here are the blocks that will blink the LEDs that are connected to GPIO16 & GPIO17 time 10 times, then turn off the remaining lit LED.","title":"Blink"},{"location":"pico/basics/blink/#blink-in-bipes","text":"","title":"Blink in BIPES"},{"location":"pico/basics/blink/#overview","text":"In this lab, we will use BIPES to make the green on-board LED on the Raspberry Pi Pico blink on and off every half second. The only things you need to run this program are BIPES a USB cable a $4 Raspberry Pi Pico microcontroller","title":"Overview"},{"location":"pico/basics/blink/#blinking-the-builtin-led","text":"The pico has a single built in green LED wired to logical pin 25. We call this GPIO 25. GPIO means General Purpose Input and Output pin. Here is a sample program that you can use. Don't worry about understanding each block yet. We will cover the various parts in later sections. Take a look at the left navigation. Each section in the navigation contains different items that you will use to run your program. We used blocks from Loops , Logic , Machine:In_Out Pins , and Timing . The green block comes from the Loops navigation section. Anything inside the green block repeats while true . true comes from the Logic navigation section. Thus the program will run forever, or until we stop it. The first blook inside the loop comes from the Machine:In/Out Pins navigation section. We are setting the onboard LED to true (on). The next block is a delay for 1/2 second. The delay comes from the Timing navigation section. We repeat those two blocks, this time setting the onboard LED to false (off).","title":"Blinking the Builtin LED"},{"location":"pico/basics/blink/#changing-the-blink-speed","text":"Next, lets create a variable from the Variable navigation section for the delay that the LED is on and off. The number in the delay block comes from the Math navigation section. This program will blink the built-in LED on and off every 1/4 of a second. By changing the delay variable you can make the LED blink faster and slower. Challenge What is the fastest you can make the LED blink and still see it changing? What does this tell you about the human eye?","title":"Changing the Blink Speed"},{"location":"pico/basics/blink/#blinking-external-leds","text":"Although the builtin LED is convenient, you can use the code to blink any number of external LEDs that are connected through a 330 ohm resister in series to the LED. Hints: We will assume that LEDs are connected to pins GPIO16 and GPIO17 and are connected via a 330 ohm resistor to ground. The longer lead on the LED is the Anode (+) lead, connect it to the GPIO pins on the pico Modify the first program Note which GPIO pins are connected to each LED Here are the blocks that will blink the LEDs that are connected to GPIO16 & GPIO17 time 10 times, then turn off the remaining lit LED.","title":"Blinking external LEDs"},{"location":"pico/basics/button/","text":"Button In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard . Momentary Switch Buttons We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code. Sample Button Polling Code Here is our fist example that uses a simple \"watching\" loop to check if the button value has changed 10 times per second. In this case, the built-in LED is connected to pin 25. Interrupt Handler Version Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handle external events such as a button press. You can see the count of button presses in the console. Interrupt Handler with a Debounce Feature One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here are the blocks of this \"Debounce\" code: References Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"Button"},{"location":"pico/basics/button/#button","text":"In this lesson we will hook a single momentary push button up to our Raspberry Pi Nano. We will use it to toggle the built-in LED. We will start out with simply polling the button 10 times a second to check it's state. Then we will show how to use an interrupt handler function to monitor events from the button. In the example above, we are connecting the button on the left to the lower-left corner pin of the Raspberry Pi Pico. This is GPIO Pin 15 and is in row number 20 of our breadboard .","title":"Button"},{"location":"pico/basics/button/#momentary-switch-buttons","text":"We use \"B3F\" tactile switch buttons that can be mounted directly on our breadboards. When the button is pressed, it connects a wire that joins two pins on one side to the two pins on the other side. The buttons can be mounted directly over the trough in the center of the breadboard. They typically cost under $2 for 10 buttons or about 20 cents per button. Here are the internal connections within the switch. This is the connection diagram that shows how the button is connected to the GPIO connector in the lower-left corner of the Raspberry Pi Pico. This corresponds to GP15 or Pin #15 in our code.","title":"Momentary Switch Buttons"},{"location":"pico/basics/button/#sample-button-polling-code","text":"Here is our fist example that uses a simple \"watching\" loop to check if the button value has changed 10 times per second. In this case, the built-in LED is connected to pin 25.","title":"Sample Button Polling Code"},{"location":"pico/basics/button/#interrupt-handler-version","text":"Although the polling version is simple, it does take a lot of the CPU resources. The button.value() is checked 10 times a second, even though the button might only be pressed once a day! A more efficient version uses a strategy called an interrupt handler . This is a function that is \"registered\" by micropython to handle external events such as a button press. You can see the count of button presses in the console.","title":"Interrupt Handler Version"},{"location":"pico/basics/button/#interrupt-handler-with-a-debounce-feature","text":"One of the problems with most switches is that they don't turn on and off perfectly each time. As the connection is getting close to closing some electrons jump the gap and the switch appears to turn on for a few microseconds. So to a computer, this looks like someone quickly pressing a button rapidly until it is firmly closed or completely open. This intermediate stage between completely open and closed is called the \"bounce\" stage of a switch opening and closing. To remove this problem and get a clean signal, we can use either a hardware solution (wiring a capacitor to remove the high frequency noise) or we can be clever and solve the problem with a few extra lines of code. The secret is to setup a timer when the switch is first closed or opened. We then ignore all the crazy stuff that happens for about 1/5th of a second (200 milliseconds). By then we usually have a solid indication that the button is changing state and we can return the new value. Here are the blocks of this \"Debounce\" code:","title":"Interrupt Handler with a Debounce Feature"},{"location":"pico/basics/button/#references","text":"Raspberry Pi Pico Getting Started Guide Lab 6 YouTube Video Sample eBay List of Switches with trough pins Sample B3F Button on eBay 10 pieces for $1.50","title":"References"},{"location":"pico/basics/fadeInAndOut/","text":"Fade an LED in and Out In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want. Welcome to Pulse Width Modulation Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? The rate of change of the pulse is called the frequency. How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. A GPIO pin is declared a PWM output when you use the PWM block found in the Machine: In/Out Pins navigation section. The block initializes a pin to be a PWM pin. Frequency and duty cycle can then be set individually. Conversly, the RPI PWM block lets you set both the frequency and duty cycle when the pin is initalized. Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again. Suggested Exercises Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM? Note that we will cover up doing \"cleanup\" events that stop all PWM activity in our Interrupt Handlers Lab References Pulse With Modulation Wikipedia Article on Pulse With Modulation","title":"Fade in and out"},{"location":"pico/basics/fadeInAndOut/#fade-an-led-in-and-out","text":"In the prior Blink lab, we turned an LED on an off at different speeds. But what if we want to slowly turn on our LED on and off? In this lab we will show you how to dim your LED to any brightness level you want.","title":"Fade an LED in and Out"},{"location":"pico/basics/fadeInAndOut/#welcome-to-pulse-width-modulation","text":"Although digital computers are good at quickly turning signals on and off, they don't really allow us to easily set an output to a given voltage level without complex circuits. But there is an easier way to adjust the brightness of an LED! We can quickly turn the signal to the LED on and off. We can do this so quickly that you can't even see it flicker. Controlling the amount of time a signal is on is all about controlling the width of the ON pulse. That is why this is called Pulse Width Modulation or PWM for short. With a PWM design there are two things we need to tell the microcontroller: How often do you want a square wave to go on and off? The rate of change of the pulse is called the frequency. How wide should the on part of the pulse be (relative to the total width). This is called the duty cycle. A GPIO pin is declared a PWM output when you use the PWM block found in the Machine: In/Out Pins navigation section. The block initializes a pin to be a PWM pin. Frequency and duty cycle can then be set individually. Conversly, the RPI PWM block lets you set both the frequency and duty cycle when the pin is initalized. Note that we can slow the frequency way down and the dimming effect will still work. As an experiment you can change the PWM frequency to around 20 and you will see a distinct flicker as the LED turns on. Here is the sample program that will slowly dim the builtin LED that is on pin 25: Note that the duty cycle starts at 0 (always off) and moves slowly up to 65,025 (always on). It then does the reverse and slowly dims the LED and then repeats. There is only a 1/10,000 of a delay between these changes so the LED will completely turn on in about six seconds before it starts to dim again.","title":"Welcome to Pulse Width Modulation"},{"location":"pico/basics/fadeInAndOut/#suggested-exercises","text":"Change the frequency from 1,000 to 500, 100, 50, 40, 30, 25, 20, and 10. When can you just barley see it flicker? What does this tell you about the human eye? Can you add a delay so that the LED stays on at full brightness for one second before it starts to dim again? Can you add a delay so that the LED is completely off for five seconds and then goes to full brightness and off in one second? What lights in your home would you like to see slowly dim on and off? How could you modify a light (safely) so that it slowly dimmed on and off. Would PWM work with all lightbulb types such as tungsten filament bulbs that take a long time to heat up and cool down? Can you hook up a set of red, green and blue LEDs program them to fade in and out to display all the colors of the rainbow (red, orange, yellow, green, blue, indigo and violet)? When you stop the program does the LED stop changing brightness? Does it retain the value that it had when you pressed the Stop function? What does that tell you about how main CPU and the role of PWM? Note that we will cover up doing \"cleanup\" events that stop all PWM activity in our Interrupt Handlers Lab","title":"Suggested Exercises"},{"location":"pico/basics/fadeInAndOut/#references","text":"","title":"References"},{"location":"pico/basics/fadeInAndOut/#pulse-with-modulation","text":"Wikipedia Article on Pulse With Modulation","title":"Pulse With Modulation"},{"location":"pico/basics/neopixel/","text":"NeoPixels NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of March of 2022 there is now built-in support for NeoPixels in the MicroPython 1.18 runtime for the Raspberry Pi RP2040 microcontroller. Although you can still use custom libraries, this tutorial assumes you are using version 1.18 or later. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266 Different Types of NeoPixels There are many different types of NeoPixels. They come in many forms such as strips, rings and matrices. The most common type of NeoPixels are strips. The strips come in a variety of densities and waterproofing. The most common and easiest to use are the 60 pixels-per-meter type. Circuit connections LED Strip Pico Name Pico Pin Description GND GND 38 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 0 Row 1 on the left side Note that you can also power most of the LED strips using the 3.3 volts available on Grove connectors. The only difference is the brightness might not be quite as high, but for most applications this will not be a problem. Setup Parameters Our block will have two parts: Initialization of the NeoPixel object using the static block parameters. This is also done just once. Sending the drawing commands to the device through the data port. This is usually done within a main loop. Sample Programs Now we are ready to write our first small test program! Move Red Pixel Across Strip Fade in and Out Make the first pixel fade the red color in and out. We do this by slowly turning up the color level of the red on the NeoPixel. We start a 0 and go up to 255. Then we go back from 255 back down to zero. We delay about 5 milliseconds between each of the 255 brightness levels. Heartbeat Lab What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an electro cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. The following blocks emulate this heart beat pattern: Move Red, Green and Blue The following program will just take the blocks in the loop above and move it into a function, then call the function with red, blue, and green. Rainbow Cycle The program cycles each pixel through all the colors in a rainbow. It uses two functions: wheel(pos) this function takes a position parameter from 0 to 255 and returns a triple of numbers for the red, green and blue values as the position moves around the color wheel. This is a handy program anytime you want to cycle through all the colors of the rainbow! rainbow_cycle will cycle each of the pixels in a strip through the color wheel. It gives the appearance that colors are moving across the strip. The wait is the delay time between updating the colors. A typical value for wait is .05 seconds or 50 milliseconds. References MicroPython RP2 Reference for NeoPixel Driver Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel (used before version 1.18 of the MicroPython RP2 Runtime) - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"NeoPixel"},{"location":"pico/basics/neopixel/#neopixels","text":"NeoPixels are Red-Green-Blue LEDs that are designed to makes them easy to control with three wires: GND, +5V and a single serial data line. They are very popular with our students because they are powerful, easy to program and full of bling . Note As of March of 2022 there is now built-in support for NeoPixels in the MicroPython 1.18 runtime for the Raspberry Pi RP2040 microcontroller. Although you can still use custom libraries, this tutorial assumes you are using version 1.18 or later. Controlling NeoPixels is challenging since the timing of data being sent must be very precise. Python alone is not fast enough to send bits out of a serial port. So a small function that uses assembly code is used. This code can be called directly from a neopixel driver file so that the user's don't need to see this code. MicroPython Example Code on ESP8266","title":"NeoPixels"},{"location":"pico/basics/neopixel/#different-types-of-neopixels","text":"There are many different types of NeoPixels. They come in many forms such as strips, rings and matrices. The most common type of NeoPixels are strips. The strips come in a variety of densities and waterproofing. The most common and easiest to use are the 60 pixels-per-meter type.","title":"Different Types of NeoPixels"},{"location":"pico/basics/neopixel/#circuit-connections","text":"LED Strip Pico Name Pico Pin Description GND GND 38 Ground 5v VBUS 40 Voltage from the USB bus. Top right with USB on top Data GP0 0 Row 1 on the left side Note that you can also power most of the LED strips using the 3.3 volts available on Grove connectors. The only difference is the brightness might not be quite as high, but for most applications this will not be a problem.","title":"Circuit connections"},{"location":"pico/basics/neopixel/#setup-parameters","text":"Our block will have two parts: Initialization of the NeoPixel object using the static block parameters. This is also done just once. Sending the drawing commands to the device through the data port. This is usually done within a main loop.","title":"Setup Parameters"},{"location":"pico/basics/neopixel/#sample-programs","text":"Now we are ready to write our first small test program!","title":"Sample Programs"},{"location":"pico/basics/neopixel/#move-red-pixel-across-strip","text":"","title":"Move Red Pixel Across Strip"},{"location":"pico/basics/neopixel/#fade-in-and-out","text":"Make the first pixel fade the red color in and out. We do this by slowly turning up the color level of the red on the NeoPixel. We start a 0 and go up to 255. Then we go back from 255 back down to zero. We delay about 5 milliseconds between each of the 255 brightness levels.","title":"Fade in and Out"},{"location":"pico/basics/neopixel/#heartbeat-lab","text":"What if you were building a robot and you wanted to flash the LED to look like a human heartbeat? Instead of slowing fading in and out, you would want the brightness to follow the electrical signals coming from the heart. This is called an electro cardiogram (EKG) and it look like this: Notice that the signal is low for about one second and then it spikes up to maximum brightness and then comes back down. When we are moving the brightness up and down, we don't have to pause between each of the 256 brightness values. The eye can't usually see the intermediate brightness values if the brightness is changing quickly. To make our code efficient we can skip over 9 out of 10 of the brightness gradations between 0 and 255. The following blocks emulate this heart beat pattern:","title":"Heartbeat Lab"},{"location":"pico/basics/neopixel/#move-red-green-and-blue","text":"The following program will just take the blocks in the loop above and move it into a function, then call the function with red, blue, and green.","title":"Move Red, Green and Blue"},{"location":"pico/basics/neopixel/#rainbow-cycle","text":"The program cycles each pixel through all the colors in a rainbow. It uses two functions: wheel(pos) this function takes a position parameter from 0 to 255 and returns a triple of numbers for the red, green and blue values as the position moves around the color wheel. This is a handy program anytime you want to cycle through all the colors of the rainbow! rainbow_cycle will cycle each of the pixels in a strip through the color wheel. It gives the appearance that colors are moving across the strip. The wait is the delay time between updating the colors. A typical value for wait is .05 seconds or 50 milliseconds.","title":"Rainbow Cycle"},{"location":"pico/basics/neopixel/#references","text":"MicroPython RP2 Reference for NeoPixel Driver Core Electronics: How to use WS2812B RGB LEDs with Raspberry Pi Pico - HTML page, sample code and video MicroPython Library for NeoPixel (used before version 1.18 of the MicroPython RP2 Runtime) - note the lack of support for the RP2040 microcontroller. rp2 port no module named array","title":"References"},{"location":"pico/basics/potentiometer/","text":"MicroPython Potentiometer Lab In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED. About Analog to Digital Converters Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin. Circuit Diagram Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico. Sample set of blocks To Print Potentiometer Values 1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins. Changing Blink Speed with a Potentiometer The following video shows this script in action. Changing the Brightness of the Built in LED We can change the brightness of the builtin LED by using the POT value to change the PWM duty cycle. Here is a sample set of blocks that does this:","title":"Potentiometer"},{"location":"pico/basics/potentiometer/#micropython-potentiometer-lab","text":"In this lab we will use a 10K ohm potentiometer to demonstrate how a turn of a knob can result in getting a continuous variable from a user into our code. We will show how we can use a potentiometer to change the blinking speed of on LED.","title":"MicroPython Potentiometer Lab"},{"location":"pico/basics/potentiometer/#about-analog-to-digital-converters","text":"Digital microcontrollers are inherently noisy. They have clocks that pull power from the power supply and cause voltage fluctuations when we compare a signal to these power lines. This makes it difficult to get ADC_VREF is the ADC power supply (and reference) voltage, and is generated on Pico by filtering the 3.3V supply. This pin can be used with an external reference if better ADC performance is required. AGND is the ground reference for GPIO26-29, there is a separate analog ground plane running under these signals and terminating at this pin.","title":"About Analog to Digital Converters"},{"location":"pico/basics/potentiometer/#circuit-diagram","text":"Connect the top rail of the potentiometer to row 6 which is the ADC_VREF pin. Connect the center tap to row 10 which is ADC0 Connect row 8 to the bottom rail of the potentiometer to the Analog Ground (AGND) pin Note: to get an accurate noise-free reading from the potentiometer you must use the ADC_VREF and the AGND pins. These are special pins designed to reduce the noise on the power areas of the pico.","title":"Circuit Diagram"},{"location":"pico/basics/potentiometer/#sample-set-of-blocks-to-print-potentiometer-values","text":"1 2 3 4 5 6 7 graph LR p[Pico]-->|ADC_VREF 36 row=6| pos(Positive) p[Pico]-->|AGND 33 row=8| neg(Negative) p[Pico]-->|GP26 pin=26 ADC0 31 row=10| tap(Center Tap) pos(Positive) --- pot(Potentiometer) neg(Negative) --- pot(Potentiometer) tap(Center Tap) --- pot(Potentiometer) Connect the positive to pin 35 ADC_REF (row 6 on the breadboard) and the negative to pin 33 AGND (row 8 on the breadboard). The Pico has special noise reduction circuits to avoid power supply jitter on these reference pins.","title":"Sample set of blocks To Print Potentiometer Values"},{"location":"pico/basics/potentiometer/#changing-blink-speed-with-a-potentiometer","text":"The following video shows this script in action.","title":"Changing Blink Speed with a Potentiometer"},{"location":"pico/basics/potentiometer/#changing-the-brightness-of-the-built-in-led","text":"We can change the brightness of the builtin LED by using the POT value to change the PWM duty cycle. Here is a sample set of blocks that does this:","title":"Changing the Brightness of the Built in LED"},{"location":"pico/motors/01-intro/","text":"Motors Labs Put the robot on the floor for these labs.","title":"Introduction"},{"location":"pico/motors/01-intro/#motors-labs","text":"Put the robot on the floor for these labs.","title":"Motors Labs"},{"location":"pico/sensors/01-intro/","text":"Sensors Ultrasonic Distance Ping Sensor","title":"Introduction"},{"location":"pico/sensors/01-intro/#sensors","text":"","title":"Sensors"},{"location":"pico/sensors/01-intro/#ultrasonic-distance-ping-sensor","text":"","title":"Ultrasonic Distance Ping Sensor"}]}